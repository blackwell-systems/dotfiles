#!/usr/bin/env bash
# ============================================================
# dotfiles-doctor - Comprehensive dotfiles health check
#
# Usage:
#   dotfiles doctor          # Run all checks
#   dotfiles doctor --fix    # Auto-fix permissions
#   dotfiles doctor --quick  # Fast checks only
#
# Combines: health check + vault status + update check
# ============================================================
set -uo pipefail

# Find dotfiles directory using paths helper
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$(dirname "$SCRIPT_DIR")/lib/_paths.sh" ]]; then
    source "$(dirname "$SCRIPT_DIR")/lib/_paths.sh"
    DOTFILES_DIR="${DOTFILES_DIR:-$(get_dotfiles_dir 2>/dev/null || echo "")}"
fi

# Fallback to manual detection if _paths.sh not available or failed
if [[ -z "${DOTFILES_DIR:-}" || ! -d "${DOTFILES_DIR:-}" ]]; then
    if [[ -n "${DOTFILES_DIR:-}" && -d "${DOTFILES_DIR}" ]]; then
        : # Already set and valid
    elif [[ -d "/workspace/dotfiles" ]]; then
        DOTFILES_DIR="/workspace/dotfiles"
    elif [[ -d "$HOME/workspace/dotfiles" ]]; then
        DOTFILES_DIR="$HOME/workspace/dotfiles"
    else
        echo "Error: Could not find dotfiles directory"
        echo "Expected: /workspace/dotfiles or ~/workspace/dotfiles"
        echo ""
        echo "Set DOTFILES_DIR or WORKSPACE_TARGET environment variable:"
        echo "  export DOTFILES_DIR=/path/to/dotfiles"
        echo "  export WORKSPACE_TARGET=~/code"
        exit 1
    fi
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Counters
CHECKS_PASSED=0
CHECKS_FAILED=0
CHECKS_WARNED=0

# Track failed checks and their fixes
declare -a FAILED_CHECKS
declare -a FAILED_FIXES
declare -a WARNING_CHECKS
declare -a WARNING_FIXES

# Parse arguments
FIX_MODE=false
QUICK_MODE=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --fix|-f)
            FIX_MODE=true
            shift
            ;;
        --quick|-q)
            QUICK_MODE=true
            shift
            ;;
        --help|-h)
            echo "dotfiles-doctor - Comprehensive dotfiles health check"
            echo ""
            echo "Usage: dotfiles doctor [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --fix, -f      Auto-fix permission issues"
            echo "  --quick, -q    Run quick checks only (skip vault)"
            echo "  --help, -h     Show this help"
            exit 0
            ;;
        *)
            shift
            ;;
    esac
done

# Logging functions
pass() {
    echo -e "${GREEN}‚úì${NC} $1"
    ((CHECKS_PASSED++))
}

fail() {
    echo -e "${RED}‚úó${NC} $1"
    FAILED_CHECKS+=("$1")
    if [[ -n "${2:-}" ]]; then
        FAILED_FIXES+=("$2")
    else
        FAILED_FIXES+=("")
    fi
    ((CHECKS_FAILED++))
}

warn() {
    echo -e "${YELLOW}!${NC} $1"
    WARNING_CHECKS+=("$1")
    if [[ -n "${2:-}" ]]; then
        WARNING_FIXES+=("$2")
    else
        WARNING_FIXES+=("")
    fi
    ((CHECKS_WARNED++))
}

info() {
    echo -e "${BLUE}‚Ñπ${NC} $1"
}

section() {
    echo ""
    echo -e "${BOLD}${CYAN}‚îÄ‚îÄ $1 ‚îÄ‚îÄ${NC}"
}

# Run hook via zsh (since hooks library is zsh)
run_hook() {
    local hook_point="$1"

    # Skip if zsh not available
    command -v zsh &>/dev/null || return 0

    # Skip if hooks library doesn't exist
    [[ -f "$DOTFILES_DIR/lib/_hooks.sh" ]] || return 0

    # Run hooks via zsh (silently fail if hooks disabled)
    zsh -c "
        source '$DOTFILES_DIR/lib/_hooks.sh' 2>/dev/null || exit 0
        hook_run '$hook_point'
    " 2>/dev/null || true
}

# Banner
echo ""
echo -e "${BOLD}${CYAN}"
cat << 'EOF'
    ____        __  _____ __                ____             __
   / __ \____  / /_/ __(_) /__  _____      / __ \____  _____/ /_____  _____
  / / / / __ \/ __/ /_/ / / _ \/ ___/_____/ / / / __ \/ ___/ __/ __ \/ ___/
 / /_/ / /_/ / /_/ __/ / /  __(__  )_____/ /_/ / /_/ / /__/ /_/ /_/ / /
/_____/\____/\__/_/ /_/_/\___/____/     /_____/\____/\___/\__/\____/_/
EOF
echo -e "${NC}"
echo -e "${DIM}Comprehensive dotfiles health check${NC}"
echo ""

# Run pre-doctor hooks
run_hook "pre_doctor"

# ============================================================
# Section 1: Version & Updates
# ============================================================
section "Version & Updates"

# Check current version (from CHANGELOG.md)
if [[ -f "$DOTFILES_DIR/CHANGELOG.md" ]]; then
    VERSION=$(grep -m1 '^\#\# \[' "$DOTFILES_DIR/CHANGELOG.md" | sed 's/.*\[\(.*\)\].*/\1/')
    if [[ -n "$VERSION" ]]; then
        pass "Dotfiles version: $VERSION"
    else
        warn "Could not parse version from CHANGELOG.md"
    fi
else
    warn "CHANGELOG.md not found"
fi

# Check for updates (quick git fetch)
if [[ -d "$DOTFILES_DIR/.git" ]]; then
    cd "$DOTFILES_DIR"

    # Check if we can reach origin
    if git fetch origin main --dry-run 2>/dev/null; then
        LOCAL=$(git rev-parse HEAD 2>/dev/null)
        REMOTE=$(git rev-parse origin/main 2>/dev/null)

        if [[ "$LOCAL" == "$REMOTE" ]]; then
            pass "Up to date with origin/main"
        else
            BEHIND=$(git rev-list --count HEAD..origin/main 2>/dev/null || echo "?")
            warn "Behind origin/main by $BEHIND commit(s) - run: dotfiles-upgrade"
        fi
    else
        info "Could not check for updates (offline?)"
    fi
else
    warn "Not a git repository"
fi

# ============================================================
# Section 2: Core Components
# ============================================================
section "Core Components"

# Check symlinks
check_symlink() {
    local name="$1"
    local link="$2"
    local target="$3"

    if [[ -L "$link" ]]; then
        local actual_target=$(readlink "$link")
        if [[ "$actual_target" == "$target" || "$actual_target" == "$DOTFILES_DIR/$target" ]]; then
            pass "$name symlink OK"
        else
            fail "$name points to wrong target: $actual_target" "rm \"$link\" && ln -sf \"\$DOTFILES_DIR/$target\" \"$link\""
        fi
    elif [[ -e "$link" ]]; then
        warn "$name exists but is not a symlink" "mv \"$link\" \"$link.backup\" && ln -sf \"\$DOTFILES_DIR/$target\" \"$link\""
    else
        fail "$name symlink missing" "ln -sf \"\$DOTFILES_DIR/$target\" \"$link\""
    fi
}

check_symlink "~/.zshrc" "$HOME/.zshrc" "zsh/zshrc"
check_symlink "~/.p10k.zsh" "$HOME/.p10k.zsh" "zsh/p10k.zsh"

# Check ~/.claude symlink (workspace-target aware)
claude_ws_target=""
if type get_workspace_target &>/dev/null; then
    claude_ws_target="$(get_workspace_target)/.claude"
else
    claude_ws_target="$HOME/workspace/.claude"
fi
check_symlink "~/.claude" "$HOME/.claude" "$claude_ws_target"

# Check /workspace symlink (target-aware)
if [[ -L "/workspace" ]]; then
    actual_target=$(readlink /workspace 2>/dev/null)
    if type get_workspace_target &>/dev/null; then
        expected_target=$(get_workspace_target)
    else
        expected_target="$HOME/workspace"
    fi
    if [[ "$actual_target" == "$expected_target" ]]; then
        pass "/workspace symlink correct -> $expected_target"
    else
        warn "/workspace -> $actual_target (expected: $expected_target)"
    fi
else
    warn "/workspace symlink not configured (optional for multi-machine)"
fi

# ============================================================
# Section 3: Required Commands
# ============================================================
section "Required Commands"

check_command() {
    local cmd="$1"
    local pkg="${2:-$1}"

    if command -v "$cmd" >/dev/null 2>&1; then
        local version=$("$cmd" --version 2>/dev/null | head -1 | cut -d' ' -f2- | head -c 30)
        pass "$cmd ${DIM}($version)${NC}"
    else
        fail "$cmd not found" "brew install $pkg"
    fi
}

check_command "zsh"
check_command "git"
check_command "brew" "homebrew"
check_command "jq"

# Optional: vault CLI tools
if command -v bw >/dev/null 2>&1; then
    pass "bw (Bitwarden CLI)"
elif command -v op >/dev/null 2>&1; then
    pass "op (1Password CLI)"
elif command -v pass >/dev/null 2>&1; then
    pass "pass (standard Unix password manager)"
else
    info "No vault CLI installed (optional - for vault features)"
fi

# ============================================================
# Section 4: SSH Configuration
# ============================================================
section "SSH Configuration"

SSH_DIR="$HOME/.ssh"

if [[ -d "$SSH_DIR" ]]; then
    # Check directory permissions
    perms=$(stat -c "%a" "$SSH_DIR" 2>/dev/null || stat -f "%OLp" "$SSH_DIR" 2>/dev/null)
    if [[ "$perms" == "700" ]]; then
        pass "~/.ssh directory permissions (700)"
    else
        if $FIX_MODE; then
            chmod 700 "$SSH_DIR"
            pass "~/.ssh permissions fixed to 700"
        else
            fail "~/.ssh has permissions $perms (should be 700)" "chmod 700 ~/.ssh"
        fi
    fi

    # Check for SSH keys
    key_count=$(find "$SSH_DIR" -name "id_*" -not -name "*.pub" 2>/dev/null | wc -l)
    if [[ $key_count -gt 0 ]]; then
        pass "Found $key_count SSH private key(s)"

        # Check key permissions
        for key in "$SSH_DIR"/id_*; do
            [[ -f "$key" && ! "$key" == *.pub ]] || continue
            perms=$(stat -c "%a" "$key" 2>/dev/null || stat -f "%OLp" "$key" 2>/dev/null)
            if [[ "$perms" != "600" ]]; then
                if $FIX_MODE; then
                    chmod 600 "$key"
                    pass "Fixed permissions on $(basename "$key")"
                else
                    fail "$(basename "$key") has permissions $perms (should be 600)" "chmod 600 \"$key\""
                fi
            fi
        done
    else
        warn "No SSH keys found in ~/.ssh" "ssh-keygen -t ed25519 -C \"your_email@example.com\""
    fi
else
    warn "~/.ssh directory does not exist" "mkdir -p ~/.ssh && chmod 700 ~/.ssh"
fi

# ============================================================
# Section 5: AWS Configuration (if present)
# ============================================================
if [[ -d "$HOME/.aws" ]] || command -v aws >/dev/null 2>&1; then
    section "AWS Configuration"

    if [[ -f "$HOME/.aws/config" ]]; then
        pass "~/.aws/config exists"
    else
        warn "~/.aws/config not found"
    fi

    if [[ -f "$HOME/.aws/credentials" ]]; then
        perms=$(stat -c "%a" "$HOME/.aws/credentials" 2>/dev/null || stat -f "%OLp" "$HOME/.aws/credentials" 2>/dev/null)
        if [[ "$perms" == "600" ]]; then
            pass "~/.aws/credentials permissions (600)"
        else
            if $FIX_MODE; then
                chmod 600 "$HOME/.aws/credentials"
                pass "Fixed ~/.aws/credentials permissions"
            else
                fail "~/.aws/credentials has permissions $perms (should be 600)" "chmod 600 ~/.aws/credentials"
            fi
        fi
    else
        info "~/.aws/credentials not found (using SSO or IAM roles?)"
    fi
fi

# ============================================================
# Section 6: Vault Status (unless quick mode)
# ============================================================
if ! $QUICK_MODE; then
    if command -v bw >/dev/null 2>&1; then
        section "Vault Status (Bitwarden)"

        if bw login --check >/dev/null 2>&1; then
            pass "Logged in to Bitwarden"

            # Check if unlocked
            if bw unlock --check >/dev/null 2>&1; then
                pass "Vault is unlocked"
            else
                warn "Vault is locked" "dotfiles vault unlock"
            fi
        else
            warn "Not logged in to Bitwarden" "bw login && dotfiles vault unlock"
        fi
    elif command -v op >/dev/null 2>&1; then
        section "Vault Status (1Password)"

        if op account get >/dev/null 2>&1; then
            pass "Signed in to 1Password"
        else
            warn "Not signed in to 1Password" "dotfiles vault unlock"
        fi
    elif command -v pass >/dev/null 2>&1; then
        section "Vault Status (pass)"

        if [[ -d "$HOME/.password-store" ]]; then
            pass "Password store initialized"
        else
            warn "Password store not initialized" "pass init <gpg-id>"
        fi
    fi
fi

# ============================================================
# Section 7: Shell Configuration
# ============================================================
section "Shell Configuration"

# Check default shell
if [[ "$SHELL" == *"zsh"* ]]; then
    pass "Default shell is zsh"
else
    warn "Default shell is $SHELL (expected zsh)" "chsh -s \$(which zsh)"
fi

# Check zsh modules exist
if [[ -d "$DOTFILES_DIR/zsh/zsh.d" ]]; then
    module_count=$(find "$DOTFILES_DIR/zsh/zsh.d" -name "*.zsh" | wc -l)
    pass "Found $module_count zsh modules in zsh.d/"
else
    warn "zsh.d/ directory not found"
fi

# Check Powerlevel10k
if [[ -f "$HOME/.p10k.zsh" ]]; then
    pass "Powerlevel10k configuration exists"
else
    warn "Powerlevel10k configuration missing"
fi

# ============================================================
# Section 8: Claude Code (Optional)
# ============================================================
if command -v claude &>/dev/null; then
    section "Claude Code"
    pass "Claude CLI installed"

    if command -v dotclaude &>/dev/null; then
        pass "dotclaude installed"
        profile=$(dotclaude active 2>/dev/null)
        if [[ -n "$profile" && "$profile" != "none" ]]; then
            pass "Active profile: $profile"
        else
            warn "No active profile - run: dotclaude switch <profile>"
        fi

        # Check profiles.json exists for vault sync
        if [[ -f "$HOME/.claude/profiles.json" ]]; then
            pass "profiles.json exists (vault syncable)"
        else
            info "profiles.json not found - run: dotclaude activate <profile>"
        fi
    else
        info "dotclaude not installed (optional)"
        echo "     Manage Claude profiles across machines:"
        echo "     See: github.com/blackwell-systems/dotclaude"
    fi
fi

# ============================================================
# Section 9: Template System
# ============================================================
section "Template System"

TEMPLATES_DIR="$DOTFILES_DIR/templates"
GENERATED_DIR="$DOTFILES_DIR/generated"

# Check if template system is configured
if [[ -f "$TEMPLATES_DIR/_variables.local.sh" ]]; then
    pass "Template variables configured"

    # Check if templates are rendered
    if [[ -d "$GENERATED_DIR" ]]; then
        generated_count=$(find "$GENERATED_DIR" -type f 2>/dev/null | wc -l)
        if [[ $generated_count -gt 0 ]]; then
            pass "Found $generated_count generated config(s)"

            # Check for stale templates
            stale_count=0
            shopt -s nullglob
            for tmpl in "$TEMPLATES_DIR/configs"/*.tmpl; do
                [[ -f "$tmpl" ]] || continue
                basename="${tmpl##*/}"
                basename="${basename%.tmpl}"
                generated="$GENERATED_DIR/$basename"

                if [[ -f "$generated" && "$tmpl" -nt "$generated" ]]; then
                    ((stale_count++))
                fi
            done
            shopt -u nullglob

            if [[ $stale_count -gt 0 ]]; then
                warn "$stale_count template(s) need re-rendering" "dotfiles template render"
            else
                pass "All generated configs up to date"
            fi
        else
            warn "No generated configs" "dotfiles template render"
        fi
    else
        warn "Generated directory missing" "mkdir -p \"$DOTFILES_DIR/generated\" && dotfiles template render"
    fi
else
    info "Template system not configured (optional)"
    info "Run 'dotfiles template init' to set up machine-specific configs"
fi

# ============================================================
# Section 10: Custom Checks (via hooks)
# ============================================================
# Run doctor_check hooks - users can add custom validation
run_hook "doctor_check"

# Run post-doctor hooks
run_hook "post_doctor"

# ============================================================
# Summary with Health Score Interpretation
# ============================================================
echo ""
echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo ""

TOTAL=$((CHECKS_PASSED + CHECKS_FAILED + CHECKS_WARNED))

# Calculate health score
if [[ $CHECKS_FAILED -eq 0 && $CHECKS_WARNED -eq 0 ]]; then
    HEALTH_SCORE=100
    SCORE_STATUS="Healthy"
    SCORE_COLOR="${GREEN}"
    SCORE_ICON="üü¢"
elif [[ $CHECKS_FAILED -eq 0 ]]; then
    HEALTH_SCORE=$((100 - (CHECKS_WARNED * 5)))
    if [[ $HEALTH_SCORE -ge 80 ]]; then
        SCORE_STATUS="Healthy"
        SCORE_COLOR="${GREEN}"
        SCORE_ICON="üü¢"
    else
        SCORE_STATUS="Minor Issues"
        SCORE_COLOR="${YELLOW}"
        SCORE_ICON="üü°"
    fi
else
    HEALTH_SCORE=$((100 - (CHECKS_FAILED * 10) - (CHECKS_WARNED * 5)))
    [[ $HEALTH_SCORE -lt 0 ]] && HEALTH_SCORE=0

    if [[ $HEALTH_SCORE -ge 80 ]]; then
        SCORE_STATUS="Healthy"
        SCORE_COLOR="${GREEN}"
        SCORE_ICON="üü¢"
    elif [[ $HEALTH_SCORE -ge 60 ]]; then
        SCORE_STATUS="Minor Issues"
        SCORE_COLOR="${YELLOW}"
        SCORE_ICON="üü°"
    elif [[ $HEALTH_SCORE -ge 40 ]]; then
        SCORE_STATUS="Needs Work"
        SCORE_COLOR="${YELLOW}"
        SCORE_ICON="üü†"
    else
        SCORE_STATUS="Critical"
        SCORE_COLOR="${RED}"
        SCORE_ICON="üî¥"
    fi
fi

# Health score banner
echo -e "  ${SCORE_ICON}  ${BOLD}Health Score: ${SCORE_COLOR}$HEALTH_SCORE/100${NC} ${BOLD}- $SCORE_STATUS${NC}"
echo ""

# Score interpretation
echo -e "  ${DIM}Score Interpretation:${NC}"
echo -e "    üü¢ ${BOLD}80-100${NC}  Healthy      - All checks passed or minor warnings"
echo -e "    üü° ${BOLD}60-79${NC}   Minor Issues - Some warnings, safe to use"
echo -e "    üü† ${BOLD}40-59${NC}   Needs Work   - Several issues, fix recommended"
echo -e "    üî¥ ${BOLD}0-39${NC}    Critical     - Major problems, fix immediately"
echo ""

# Results summary
echo -e "  ${BOLD}Your Results:${NC}"
if [[ $CHECKS_FAILED -gt 0 ]]; then
    echo -e "    ${RED}‚úó${NC} $CHECKS_FAILED failed check(s)   ${DIM}(-$((CHECKS_FAILED * 10)) points)${NC}"
fi
if [[ $CHECKS_WARNED -gt 0 ]]; then
    echo -e "    ${YELLOW}!${NC} $CHECKS_WARNED warning(s)        ${DIM}(-$((CHECKS_WARNED * 5)) points)${NC}"
fi
if [[ $CHECKS_PASSED -gt 0 ]]; then
    echo -e "    ${GREEN}‚úì${NC} $CHECKS_PASSED passed check(s)"
fi
echo ""

# Quick fixes section
if [[ $CHECKS_FAILED -gt 0 || $CHECKS_WARNED -gt 0 ]]; then
    echo -e "  ${BOLD}Quick Fixes:${NC}"
    echo ""

    # Show failed checks with fixes
    if [[ $CHECKS_FAILED -gt 0 ]]; then
        for i in "${!FAILED_CHECKS[@]}"; do
            check="${FAILED_CHECKS[$i]}"
            fix="${FAILED_FIXES[$i]}"
            echo -e "    ${RED}‚úó${NC} ${check}"
            if [[ -n "$fix" ]]; then
                echo -e "      ${GREEN}‚Üí${NC} ${DIM}$fix${NC}"
            fi
        done
        echo ""
    fi

    # Show warnings with fixes (limit to first 3 to avoid clutter)
    if [[ $CHECKS_WARNED -gt 0 ]]; then
        warn_count=0
        for i in "${!WARNING_CHECKS[@]}"; do
            [[ $warn_count -ge 3 ]] && break
            check="${WARNING_CHECKS[$i]}"
            fix="${WARNING_FIXES[$i]}"
            echo -e "    ${YELLOW}!${NC} ${check}"
            if [[ -n "$fix" ]]; then
                echo -e "      ${GREEN}‚Üí${NC} ${DIM}$fix${NC}"
            fi
            ((warn_count++))
        done

        if [[ ${#WARNING_CHECKS[@]} -gt 3 ]]; then
            remaining=$((${#WARNING_CHECKS[@]} - 3))
            echo -e "    ${DIM}... and $remaining more warning(s)${NC}"
        fi
        echo ""
    fi

    # Auto-fix suggestion
    if [[ ! $FIX_MODE ]]; then
        fixable=0
        # Count how many issues are auto-fixable (permissions)
        for check in "${FAILED_CHECKS[@]}"; do
            if [[ "$check" == *"permissions"* ]]; then
                ((fixable++))
            fi
        done

        if [[ $fixable -gt 0 ]]; then
            echo -e "  ${BOLD}Auto-fix available for $fixable issue(s):${NC}"
            echo -e "    ${GREEN}‚Üí${NC} dotfiles doctor --fix"
            echo ""
        fi
    fi

    # Estimated improvement
    if [[ $CHECKS_FAILED -gt 0 || $CHECKS_WARNED -gt 0 ]]; then
        potential_score=$((100 - (CHECKS_WARNED * 2)))  # Assume most failures can be fixed
        [[ $potential_score -gt 100 ]] && potential_score=100

        echo -e "  ${BOLD}Potential Score:${NC} ${GREEN}$potential_score/100${NC} ${DIM}(if all issues fixed)${NC}"
        echo ""
    fi
fi

# Perfect score celebration
if [[ $HEALTH_SCORE -eq 100 ]]; then
    echo -e "  ${GREEN}${BOLD}üéâ Perfect score! Your dotfiles are healthy.${NC}"
    echo ""
fi

echo -e "${BOLD}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo ""

# Exit with appropriate code
if [[ $CHECKS_FAILED -gt 0 ]]; then
    exit 1
else
    exit 0
fi
