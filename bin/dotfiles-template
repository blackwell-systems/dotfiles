#!/usr/bin/env zsh
# ============================================================
# FILE: bin/dotfiles-template
# Template management CLI for machine-specific configurations
#
# Usage:
#   dotfiles template init          # Interactive setup
#   dotfiles template render        # Render all templates
#   dotfiles template render FILE   # Render specific template
#   dotfiles template check         # Validate template syntax
#   dotfiles template diff          # Show what would change
#   dotfiles template vars          # List all variables
#   dotfiles template edit          # Edit local variables
#   dotfiles template link          # Symlink generated files
#
# Environment Variables:
#   DEBUG=1                         # Enable debug output
#   DOTFILES_TMPL_*                 # Override any template variable
#   DOTFILES_MACHINE_TYPE           # Force machine type (work/personal)
#
# Examples:
#   dotfiles template init
#   dotfiles template render --dry-run
#   dotfiles template vars --quiet
#   DOTFILES_TMPL_GIT_EMAIL="me@example.com" dotfiles template render
# ============================================================

set -euo pipefail

# ============================================================
# Setup
# ============================================================
SCRIPT_DIR="${0:A:h}"
DOTFILES_DIR="${SCRIPT_DIR:h}"

# Source libraries
source "$DOTFILES_DIR/lib/_logging.sh"
source "$DOTFILES_DIR/lib/_templates.sh"

# ============================================================
# Usage
# ============================================================
usage() {
    print "${BOLD}dotfiles template${NC} - Machine-specific configuration management"
    print ""
    print "${CYAN}USAGE${NC}"
    print "    dotfiles template <command> [options]"
    print ""
    print "${CYAN}COMMANDS${NC}"
    print "    init              Interactive setup - creates _variables.local.sh"
    print "    render            Render all templates to generated/"
    print "    render <file>     Render a specific template file"
    print "    check             Validate template syntax"
    print "    diff              Show differences between templates and generated files"
    print "    vars              List all template variables and values"
    print "    filters           List available pipeline filters"
    print "    edit              Open _variables.local.sh in editor"
    print "    link              Create symlinks from generated files to destinations"
    print "    list              Show available templates and their status"
    print "    arrays            Manage JSON/shell arrays for {{#each}} loops"
    print "    vault <cmd>       Sync template variables with vault"
    print "    help              Show this help message"
    print ""
    print "${CYAN}VAULT COMMANDS${NC}"
    print "    vault push        Push _variables.local.sh to vault"
    print "    vault pull        Pull from vault to _variables.local.sh"
    print "    vault diff        Show differences between local and vault"
    print "    vault sync        Bidirectional sync with conflict detection"
    print "    vault status      Show vault sync status"
    print ""
    print "${CYAN}OPTIONS${NC}"
    print "    --dry-run, -n     Show what would be done without doing it"
    print "    --force, -f       Force re-render even if up to date"
    print "    --verbose, -v     Show detailed output"
    print "    --quiet, -q       Minimal output"
    print ""
    print "${CYAN}ARRAYS OPTIONS${NC}"
    print "    --export-json, -e Export shell arrays to JSON format"
    print "    --validate, -v    Validate JSON arrays file syntax"
    print ""
    print "${CYAN}EXAMPLES${NC}"
    print "    # First-time setup"
    print "    dotfiles template init"
    print ""
    print "    # See current variable values"
    print "    dotfiles template vars"
    print ""
    print "    # Preview what would be generated"
    print "    dotfiles template render --dry-run"
    print ""
    print "    # Render and link all templates"
    print "    dotfiles template render && dotfiles template link"
    print ""
    print "    # Override a variable for one render"
    print "    DOTFILES_TMPL_GIT_EMAIL=\"other@example.com\" dotfiles template render"
    print ""
    print "    # View loaded arrays (from JSON or shell)"
    print "    dotfiles template arrays"
    print ""
    print "    # Export shell arrays to JSON format"
    print "    dotfiles template arrays --export-json"
    print ""
    print "    # Validate JSON arrays file"
    print "    dotfiles template arrays --validate"
    print ""
    print "${CYAN}TEMPLATE SYNTAX${NC}"
    print "    {{ variable }}              Variable substitution"
    print "    {{ var | filter }}          Pipeline filter"
    print "    {{ var | filter \"arg\" }}    Filter with argument"
    print "    {{ var | f1 | f2 }}         Chained filters"
    print "    {{#if variable }}...{{/if}} Conditional block"
    print "    {{#if var == \"value\" }}     Conditional with comparison"
    print "    {{#unless variable }}       Negative conditional"
    print "    {{#each array }}...{{/each}} Loop over array items"
    print ""
    print "${CYAN}FILES${NC}"
    print "    templates/_variables.sh         Default variable definitions"
    print "    templates/_variables.local.sh   Machine-specific overrides (gitignored)"
    print "    templates/_arrays.local.json    JSON arrays for {{#each}} loops (gitignored)"
    print "    templates/configs/*.tmpl        Template files"
    print "    generated/*                     Rendered output (gitignored)"
    print ""
    print "${CYAN}DOCUMENTATION${NC}"
    print "    Full guide: docs/templates.md"
    print "    Online:     https://blackwell-systems.github.io/dotfiles/#/templates"
    print ""
}

# ============================================================
# Interactive Prompt Helpers
# ============================================================

# Prompt for a value with default
# Usage: prompt_value "Git name" "$default" variable_name [required]
prompt_value() {
    local label="$1"
    local default="$2"
    local varname="$3"
    local required="${4:-false}"
    local value

    if [[ -n "$default" ]]; then
        printf "  ${CYAN}%s${NC} [%s]: " "$label" "$default"
    else
        printf "  ${CYAN}%s${NC}: " "$label"
    fi

    read -r value
    value="${value:-$default}"

    if [[ "$required" == "true" && -z "$value" ]]; then
        warn "  This field is required"
        prompt_value "$label" "$default" "$varname" "$required"
        return
    fi

    eval "$varname=\"\$value\""
}

# Prompt for choice from list
# Usage: prompt_choice "Machine type" "work personal unknown" machine_type [default]
prompt_choice() {
    local label="$1"
    local choices="$2"
    local varname="$3"
    local default="${4:-}"

    print "  ${CYAN}${label}:${NC}"
    local i=1
    local choice_array=("${(@s/ /)choices}")
    for choice in $choice_array; do
        if [[ "$choice" == "$default" ]]; then
            print "    ${GREEN}$i)${NC} $choice ${DIM}(detected)${NC}"
        else
            print "    $i) $choice"
        fi
        (( i++ ))
    done

    printf "  Enter choice [1-%d]: " "${#choice_array[@]}"
    local selection
    read -r selection

    if [[ -z "$selection" && -n "$default" ]]; then
        eval "$varname=\"\$default\""
    elif [[ "$selection" =~ ^[0-9]+$ ]] && (( selection >= 1 && selection <= ${#choice_array[@]} )); then
        eval "$varname=\"\${choice_array[$selection]}\""
    else
        eval "$varname=\"\${choice_array[1]}\""
    fi
}

# ============================================================
# Commands
# ============================================================

# Interactive initialization
cmd_init() {
    local local_file="$TEMPLATES_DIR/_variables.local.sh"
    local example_file="$TEMPLATES_DIR/_variables.local.sh.example"

    print "${BOLD}Template System Setup${NC}"
    print "═════════════════════════════════════════════════════════════"
    print ""

    # Build auto vars to show current detection
    build_auto_vars

    print "${CYAN}Detected System:${NC}"
    printf "  %-20s %s\n" "Hostname:" "${TMPL_AUTO[hostname]}"
    printf "  %-20s %s\n" "OS:" "${TMPL_AUTO[os]} (${TMPL_AUTO[os_family]})"
    printf "  %-20s %s\n" "Architecture:" "${TMPL_AUTO[arch]}"
    printf "  %-20s %s\n" "User:" "${TMPL_AUTO[user]}"
    printf "  %-20s %s\n" "Machine Type:" "${TMPL_AUTO[machine_type]}"
    print ""

    # Check if local file exists
    if [[ -f "$local_file" ]]; then
        warn "Local variables file already exists: $local_file"
        print ""
        read -q "?Reconfigure? [y/N] " || { print ""; return 0; }
        print ""
    fi

    # ================================================================
    # Interactive Prompts for Essential Variables
    # ================================================================
    print "${BOLD}Essential Configuration${NC}"
    print "───────────────────────────────────────"
    print ""

    # Detect defaults from git config
    local default_name default_email default_github
    default_name=$(git config --global user.name 2>/dev/null || echo "")
    default_email=$(git config --global user.email 2>/dev/null || echo "")
    default_github=$(git config --global github.user 2>/dev/null || echo "")

    # Prompt for required values
    local git_name git_email machine_type github_user

    prompt_value "Git name (required)" "$default_name" git_name true
    prompt_value "Git email (required)" "$default_email" git_email true
    print ""

    prompt_choice "Machine type" "work personal unknown" machine_type "${TMPL_AUTO[machine_type]}"
    print ""

    prompt_value "GitHub username (optional)" "$default_github" github_user false
    print ""

    # ================================================================
    # Generate the local variables file
    # ================================================================
    print "${BOLD}Writing Configuration${NC}"
    print "───────────────────────────────────────"

    # Create the file with user's values
    cat > "$local_file" << LOCALVARS
#!/usr/bin/env zsh
# ============================================================
# FILE: templates/_variables.local.sh
# Machine-specific template variable overrides
#
# Generated by: dotfiles template init
# Generated on: $(date '+%Y-%m-%d %H:%M:%S')
#
# Edit this file to customize your configuration.
# Run 'dotfiles template render' after making changes.
# ============================================================

# ============================================================
# Git Configuration (required)
# ============================================================
TMPL_DEFAULTS[git_name]="$git_name"
TMPL_DEFAULTS[git_email]="$git_email"

# Optional: GPG signing key
# TMPL_DEFAULTS[git_signing_key]="ABCD1234EFGH5678"

# ============================================================
# Machine Type
# Values: work, personal, unknown
# ============================================================
TMPL_AUTO[machine_type]="$machine_type"

# ============================================================
# GitHub Configuration
# ============================================================
TMPL_DEFAULTS[github_user]="$github_user"

# ============================================================
# Work Machine Overrides
# Only applied when machine_type == "work"
# ============================================================
# TMPL_WORK[git_email]="your.name@company.com"
# TMPL_WORK[aws_profile]="work"
# TMPL_WORK[github_enterprise_host]="github.company.com"

# ============================================================
# Personal Machine Overrides
# Only applied when machine_type == "personal"
# ============================================================
# TMPL_PERSONAL[git_email]="personal@example.com"

# ============================================================
# SSH Hosts
# Format: name|hostname|user|identity_file|extra_options
# ============================================================
SSH_HOSTS=(
    "github|github.com|git|~/.ssh/id_ed25519|"
    # "work-bastion|bastion.company.com|admin|~/.ssh/id_ed25519_work|"
)

# ============================================================
# Advanced Configuration
# Uncomment and customize as needed
# ============================================================
# TMPL_DEFAULTS[aws_profile]="default"
# TMPL_DEFAULTS[bedrock_profile]="bedrock"
# TMPL_DEFAULTS[editor]="nvim"
# TMPL_DEFAULTS[projects_dir]="\$HOME/code"
# TMPL_DEFAULTS[enable_nvm]="true"
# TMPL_DEFAULTS[enable_k8s_prompt]="true"
LOCALVARS

    pass "Created: $local_file"
    print ""

    # ================================================================
    # Summary
    # ================================================================
    print "${BOLD}Configuration Summary${NC}"
    print "───────────────────────────────────────"
    printf "  %-20s ${GREEN}%s${NC}\n" "Git name:" "$git_name"
    printf "  %-20s ${GREEN}%s${NC}\n" "Git email:" "$git_email"
    printf "  %-20s ${GREEN}%s${NC}\n" "Machine type:" "$machine_type"
    [[ -n "$github_user" ]] && printf "  %-20s ${GREEN}%s${NC}\n" "GitHub user:" "$github_user"
    print ""

    print "${CYAN}Next steps:${NC}"
    print "  1. ${BOLD}dotfiles template vars${NC}    - Review all variables"
    print "  2. ${BOLD}dotfiles template render${NC} - Generate config files"
    print "  3. ${BOLD}dotfiles template link${NC}   - Symlink to destinations"
    print ""

    # Ask if user wants to edit for advanced config
    if confirm "Open editor for advanced configuration?"; then
        ${EDITOR:-vim} "$local_file"
    fi
}

# Render templates
cmd_render() {
    local dry_run=false
    local force=false
    local specific_file=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run|-n) dry_run=true ;;
            --force|-f) force=true ;;
            --verbose|-v) DEBUG=1 ;;
            -*)
                fail "Unknown option: $1"
                return 1
                ;;
            *)
                specific_file="$1"
                ;;
        esac
        shift
    done

    if [[ -n "$specific_file" ]]; then
        # Render specific template
        local template_path="$specific_file"

        # If just filename, look in configs/
        if [[ ! -f "$template_path" ]]; then
            template_path="$TEMPLATES_CONFIG_DIR/$specific_file"
        fi
        # Add .tmpl if missing
        if [[ ! -f "$template_path" && ! "$template_path" == *.tmpl ]]; then
            template_path="${template_path}.tmpl"
        fi

        if [[ ! -f "$template_path" ]]; then
            fail "Template not found: $specific_file"
            return 1
        fi

        local basename="${template_path:t:r}"
        local output_file="$GENERATED_DIR/$basename"

        render_template "$template_path" "$output_file" "$dry_run"
    else
        # Render all templates
        render_all_templates "$dry_run" "$force"
    fi
}

# Check template syntax
cmd_check() {
    validate_all_templates
}

# Show diff
cmd_diff() {
    local verbose=false
    [[ "${1:-}" == "-v" || "${1:-}" == "--verbose" ]] && verbose=true

    show_template_diff "$verbose"
}

# List variables
cmd_vars() {
    local quiet=false
    [[ "${1:-}" == "-q" || "${1:-}" == "--quiet" ]] && quiet=true

    if [[ "$quiet" == "true" ]]; then
        list_template_vars false
    else
        list_template_vars true
    fi
}

# Edit local variables
cmd_edit() {
    local local_file="$TEMPLATES_DIR/_variables.local.sh"

    if [[ ! -f "$local_file" ]]; then
        warn "Local variables file not found"
        print "Run 'dotfiles template init' first"
        return 1
    fi

    ${EDITOR:-vim} "$local_file"
    pass "Edited: $local_file"
    print ""
    print "${CYAN}Tip:${NC} Run 'dotfiles template render' to apply changes"
}

# Link generated files to destinations
cmd_link() {
    local dry_run=false
    [[ "${1:-}" == "--dry-run" || "${1:-}" == "-n" ]] && dry_run=true

    info "Linking generated files..."

    # Define destinations for generated files
    # Format: generated_filename -> destination_path
    typeset -A LINK_MAP=(
        [gitconfig]="$HOME/.gitconfig"
        [99-local.zsh]="$DOTFILES_DIR/zsh/zsh.d/99-local.zsh"
        [ssh-config]="$HOME/.ssh/config"
        [claude.local]="$HOME/.claude.local"
    )

    local count=0
    local errors=0

    for file dest in "${(@kv)LINK_MAP}"; do
        local src="$GENERATED_DIR/$file"

        if [[ ! -f "$src" ]]; then
            debug "Skipping (not generated): $file"
            continue
        fi

        if [[ "$dry_run" == "true" ]]; then
            dry "Would link: $src → $dest"
        else
            # Create parent directory if needed
            mkdir -p "$(dirname "$dest")"

            # Backup existing file if it's not already a symlink to our file
            if [[ -e "$dest" && ! -L "$dest" ]]; then
                local backup="${dest}.backup.$(date +%Y%m%d%H%M%S)"
                mv "$dest" "$backup"
                info "Backed up: $dest → $backup"
            elif [[ -L "$dest" ]]; then
                # Remove existing symlink
                rm "$dest"
            fi

            # Create symlink
            if ln -s "$src" "$dest"; then
                pass "Linked: $file → $dest"
                (( count++ ))
            else
                fail "Failed to link: $file"
                (( errors++ ))
            fi
        fi
    done

    if [[ $count -eq 0 && "$dry_run" != "true" ]]; then
        info "No files to link (run 'dotfiles template render' first)"
    else
        info "Linked $count file(s)"
    fi

    [[ $errors -eq 0 ]]
}

# List available templates
cmd_list() {
    print "${BOLD}Available Templates${NC}"
    print "───────────────────────────────────────"

    for template in "$TEMPLATES_CONFIG_DIR"/*.tmpl(N); do
        local basename="${template:t:r}"
        local output="$GENERATED_DIR/$basename"
        local file_status=""  # Initialize to avoid zsh printing previous value

        if [[ -f "$output" ]]; then
            if [[ "$output" -nt "$template" ]]; then
                file_status="${GREEN}✓ up to date${NC}"
            else
                file_status="${YELLOW}○ stale${NC}"
            fi
        else
            file_status="${RED}✗ not generated${NC}"
        fi

        printf "  %-25s %b\n" "$basename" "$file_status"
    done
}

# Show available filters
cmd_filters() {
    list_filters
}

# Show/manage arrays
cmd_arrays() {
    local export_json=false
    local validate=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --export-json|-e) export_json=true ;;
            --validate|-v) validate=true ;;
            *) ;;
        esac
        shift
    done

    if [[ "$export_json" == "true" ]]; then
        # Export current shell arrays to JSON
        export_arrays_to_json
        return
    fi

    if [[ "$validate" == "true" ]]; then
        local json_file="$TEMPLATES_DIR/_arrays.local.json"
        if [[ ! -f "$json_file" ]]; then
            info "No JSON arrays file found: $json_file"
            return 0
        fi
        if jq -e '.' "$json_file" &>/dev/null; then
            pass "Valid JSON: $json_file"
            # Show structure
            jq -r 'keys[]' "$json_file" | while read -r key; do
                local count=$(jq -r ".$key | length" "$json_file")
                print "  • $key: $count items"
            done
            return 0
        else
            fail "Invalid JSON: $json_file"
            jq '.' "$json_file" 2>&1 | head -5
            return 1
        fi
    fi

    # Default: list arrays
    list_template_arrays
}

# ============================================================
# Vault Integration Commands
# ============================================================

# Vault item name for template variables
VAULT_ITEM_NAME="Template-Variables"

# Get vault session (initializes vault if needed)
# Returns: session token (may be empty for pass backend)
_vault_get_session() {
    # Source vault library
    if [[ ! -f "$DOTFILES_DIR/lib/_vault.sh" ]]; then
        fail "Vault library not found"
        return 1
    fi
    source "$DOTFILES_DIR/lib/_vault.sh"

    # Initialize vault backend
    if ! vault_init; then
        fail "Failed to initialize vault"
        return 1
    fi

    # Get session
    local session
    session=$(vault_get_session 2>/dev/null) || {
        fail "Failed to get vault session"
        return 1
    }

    echo "$session"
}

# Get local file content
_get_local_content() {
    local local_file="$TEMPLATES_DIR/_variables.local.sh"
    if [[ -f "$local_file" ]]; then
        cat "$local_file"
    else
        echo ""
    fi
}

# Get vault content
_get_vault_content() {
    local session="$1"
    source "$DOTFILES_DIR/lib/_vault.sh"
    vault_init >/dev/null 2>&1
    vault_get_notes "$VAULT_ITEM_NAME" "$session" 2>/dev/null || echo ""
}

# Vault: push local to vault
cmd_vault_push() {
    local local_file="$TEMPLATES_DIR/_variables.local.sh"
    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true ;;
            *) ;;
        esac
        shift
    done

    # Check local file exists
    if [[ ! -f "$local_file" ]]; then
        fail "Local variables file not found: $local_file"
        print "Run 'dotfiles template init' first"
        return 1
    fi

    info "Pushing template variables to vault..."

    # Get session
    local session
    session=$(_vault_get_session) || return 1

    # Get content
    local local_content
    local_content=$(cat "$local_file")

    # Check if item exists in vault
    source "$DOTFILES_DIR/lib/_vault.sh"
    if vault_item_exists "$VAULT_ITEM_NAME" "$session"; then
        # Get existing content for comparison
        local vault_content
        vault_content=$(vault_get_notes "$VAULT_ITEM_NAME" "$session" 2>/dev/null || echo "")

        if [[ "$local_content" == "$vault_content" ]]; then
            info "Vault already up to date"
            return 0
        fi

        if [[ "$force" != "true" ]]; then
            warn "Item '$VAULT_ITEM_NAME' already exists in vault"
            print ""
            print "Use ${BOLD}--force${NC} to overwrite, or run ${BOLD}vault diff${NC} to see changes"
            return 1
        fi

        # Update existing
        if vault_update_item "$VAULT_ITEM_NAME" "$local_content" "$session"; then
            pass "Updated '$VAULT_ITEM_NAME' in vault"
        else
            fail "Failed to update vault item"
            return 1
        fi
    else
        # Create new
        if vault_create_item "$VAULT_ITEM_NAME" "$local_content" "$session"; then
            pass "Created '$VAULT_ITEM_NAME' in vault"
        else
            fail "Failed to create vault item"
            return 1
        fi
    fi

    # Sync if configured
    if [[ "$(config_get 'vault.auto_sync' 'false')" == "true" ]]; then
        info "Syncing vault..."
        vault_sync "$session" 2>/dev/null || true
    fi

    return 0
}

# Vault: pull from vault to local
cmd_vault_pull() {
    local local_file="$TEMPLATES_DIR/_variables.local.sh"
    local force=false
    local backup=true

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true ;;
            --no-backup) backup=false ;;
            *) ;;
        esac
        shift
    done

    info "Pulling template variables from vault..."

    # Get session
    local session
    session=$(_vault_get_session) || return 1

    # Check if item exists in vault
    source "$DOTFILES_DIR/lib/_vault.sh"
    if ! vault_item_exists "$VAULT_ITEM_NAME" "$session"; then
        fail "Item '$VAULT_ITEM_NAME' not found in vault"
        print "Push with: dotfiles template vault push"
        return 1
    fi

    # Get vault content
    local vault_content
    vault_content=$(vault_get_notes "$VAULT_ITEM_NAME" "$session")

    if [[ -z "$vault_content" ]]; then
        fail "Vault item is empty"
        return 1
    fi

    # Check if local file exists
    if [[ -f "$local_file" ]]; then
        local local_content
        local_content=$(cat "$local_file")

        if [[ "$local_content" == "$vault_content" ]]; then
            info "Local file already up to date"
            return 0
        fi

        if [[ "$force" != "true" ]]; then
            warn "Local file already exists: $local_file"
            print ""
            print "Use ${BOLD}--force${NC} to overwrite, or run ${BOLD}vault diff${NC} to see changes"
            return 1
        fi

        # Backup existing file
        if [[ "$backup" == "true" ]]; then
            local backup_file="${local_file}.backup.$(date +%Y%m%d%H%M%S)"
            cp "$local_file" "$backup_file"
            info "Backed up: $backup_file"
        fi
    fi

    # Write vault content to local file
    printf '%s\n' "$vault_content" > "$local_file"
    chmod 600 "$local_file"
    pass "Pulled '$VAULT_ITEM_NAME' from vault"
    print "  → $local_file"

    return 0
}

# Vault: show diff between local and vault
cmd_vault_diff() {
    local local_file="$TEMPLATES_DIR/_variables.local.sh"

    info "Comparing local and vault..."

    # Get session
    local session
    session=$(_vault_get_session) || return 1

    # Get local content
    local local_content=""
    local local_exists=false
    if [[ -f "$local_file" ]]; then
        local_content=$(cat "$local_file")
        local_exists=true
    fi

    # Get vault content
    source "$DOTFILES_DIR/lib/_vault.sh"
    local vault_content=""
    local vault_exists=false
    if vault_item_exists "$VAULT_ITEM_NAME" "$session"; then
        vault_content=$(vault_get_notes "$VAULT_ITEM_NAME" "$session" 2>/dev/null || echo "")
        vault_exists=true
    fi

    # Compare
    if [[ "$local_exists" == "false" && "$vault_exists" == "false" ]]; then
        info "Neither local file nor vault item exists"
        return 0
    fi

    if [[ "$local_exists" == "false" ]]; then
        print "${CYAN}Vault has content, local file missing${NC}"
        print "  Run: ${BOLD}dotfiles template vault pull${NC}"
        return 0
    fi

    if [[ "$vault_exists" == "false" ]]; then
        print "${CYAN}Local file exists, vault item missing${NC}"
        print "  Run: ${BOLD}dotfiles template vault push${NC}"
        return 0
    fi

    if [[ "$local_content" == "$vault_content" ]]; then
        pass "Local and vault are in sync"
        return 0
    fi

    # Show diff
    print "${BOLD}Differences (local vs vault):${NC}"
    print "───────────────────────────────────────"

    # Create temp files for diff
    local tmp_local=$(mktemp)
    local tmp_vault=$(mktemp)
    printf '%s\n' "$local_content" > "$tmp_local"
    printf '%s\n' "$vault_content" > "$tmp_vault"

    # Use diff with color if available
    if command -v diff >/dev/null 2>&1; then
        diff -u --label "local" --label "vault" "$tmp_local" "$tmp_vault" | while IFS= read -r line; do
            case "$line" in
                ---*|+++*) printf '%b%s%b\n' "${BOLD}" "$line" "${NC}" ;;
                @@*) printf '%b%s%b\n' "${CYAN}" "$line" "${NC}" ;;
                -*) printf '%b%s%b\n' "${RED}" "$line" "${NC}" ;;
                +*) printf '%b%s%b\n' "${GREEN}" "$line" "${NC}" ;;
                *) printf '%s\n' "$line" ;;
            esac
        done
    else
        diff "$tmp_local" "$tmp_vault" || true
    fi

    rm -f "$tmp_local" "$tmp_vault"

    print ""
    print "To update vault:  ${BOLD}dotfiles template vault push --force${NC}"
    print "To update local:  ${BOLD}dotfiles template vault pull --force${NC}"

    return 0
}

# Vault: show sync status
cmd_vault_status() {
    # Prevent zsh from echoing variable assignments
    setopt localoptions typesetsilent

    local local_file="$TEMPLATES_DIR/_variables.local.sh"

    print "${BOLD}Template Vault Status${NC}"
    print "───────────────────────────────────────"

    # Get session
    local session
    session=$(_vault_get_session) || return 1

    # Get vault backend name
    source "$DOTFILES_DIR/lib/_vault.sh"
    local backend_name
    backend_name=$(vault_name 2>/dev/null || echo "unknown")
    printf "  %-20s %s\n" "Vault backend:" "$backend_name"
    printf "  %-20s %s\n" "Vault item:" "$VAULT_ITEM_NAME"
    print ""

    # Check local file
    local local_exists=false
    local local_size=0
    local local_mtime=""
    if [[ -f "$local_file" ]]; then
        local_exists=true
        local_size=$(wc -c < "$local_file" | tr -d ' ')
        local_mtime=$(stat -c %y "$local_file" 2>/dev/null || stat -f %Sm "$local_file" 2>/dev/null || echo "unknown")
    fi

    # Check vault item
    local vault_exists=false
    local vault_size=0
    if vault_item_exists "$VAULT_ITEM_NAME" "$session"; then
        vault_exists=true
        local vault_content
        vault_content=$(vault_get_notes "$VAULT_ITEM_NAME" "$session" 2>/dev/null || echo "")
        vault_size=${#vault_content}
    fi

    # Display status
    print "${CYAN}Local:${NC}"
    if [[ "$local_exists" == "true" ]]; then
        printf "  %-20s ${GREEN}exists${NC} (%d bytes)\n" "File:" "$local_size"
        printf "  %-20s %s\n" "Path:" "$local_file"
        printf "  %-20s %s\n" "Modified:" "$local_mtime"
    else
        printf "  %-20s ${RED}missing${NC}\n" "File:"
    fi

    print ""
    print "${CYAN}Vault:${NC}"
    if [[ "$vault_exists" == "true" ]]; then
        printf "  %-20s ${GREEN}exists${NC} (%d bytes)\n" "Item:" "$vault_size"
    else
        printf "  %-20s ${RED}missing${NC}\n" "Item:"
    fi

    # Sync status
    print ""
    print "${CYAN}Sync Status:${NC}"
    if [[ "$local_exists" == "false" && "$vault_exists" == "false" ]]; then
        printf "  %-20s ${YELLOW}no data${NC}\n" "Status:"
        print "  Run: dotfiles template init"
    elif [[ "$local_exists" == "false" ]]; then
        printf "  %-20s ${YELLOW}local missing${NC}\n" "Status:"
        print "  Run: dotfiles template vault pull"
    elif [[ "$vault_exists" == "false" ]]; then
        printf "  %-20s ${YELLOW}vault missing${NC}\n" "Status:"
        print "  Run: dotfiles template vault push"
    else
        # Compare content
        local local_content=$(cat "$local_file")
        # Use subshell to capture without zsh's typeset echo behavior
        local vault_content
        vault_content="$(vault_get_notes "$VAULT_ITEM_NAME" "$session" 2>/dev/null || true)"

        if [[ "$local_content" == "$vault_content" ]]; then
            printf "  %-20s ${GREEN}in sync${NC}\n" "Status:"
        else
            printf "  %-20s ${YELLOW}out of sync${NC}\n" "Status:"
            print "  Run: dotfiles template vault diff"
        fi
    fi

    return 0
}

# Vault: bidirectional sync with conflict detection
cmd_vault_sync() {
    local local_file="$TEMPLATES_DIR/_variables.local.sh"
    local force=false
    local prefer=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true ;;
            --prefer-local) prefer="local" ;;
            --prefer-vault) prefer="vault" ;;
            *) ;;
        esac
        shift
    done

    info "Syncing template variables..."

    # Get session
    local session
    session=$(_vault_get_session) || return 1

    # Get local content
    source "$DOTFILES_DIR/lib/_vault.sh"
    local local_content=""
    local local_exists=false
    if [[ -f "$local_file" ]]; then
        local_content=$(cat "$local_file")
        local_exists=true
    fi

    # Get vault content
    local vault_content=""
    local vault_exists=false
    if vault_item_exists "$VAULT_ITEM_NAME" "$session"; then
        vault_content=$(vault_get_notes "$VAULT_ITEM_NAME" "$session" 2>/dev/null || echo "")
        vault_exists=true
    fi

    # Sync logic
    if [[ "$local_exists" == "false" && "$vault_exists" == "false" ]]; then
        info "Neither local file nor vault item exists"
        print "Run: dotfiles template init"
        return 0
    fi

    if [[ "$local_exists" == "false" ]]; then
        # Only vault exists - pull
        info "Local file missing, pulling from vault..."
        cmd_vault_pull --force
        return $?
    fi

    if [[ "$vault_exists" == "false" ]]; then
        # Only local exists - push
        info "Vault item missing, pushing to vault..."
        cmd_vault_push
        return $?
    fi

    # Both exist - check if in sync
    if [[ "$local_content" == "$vault_content" ]]; then
        pass "Already in sync"
        return 0
    fi

    # Conflict detected
    warn "Conflict detected: local and vault differ"
    print ""

    if [[ -n "$prefer" ]]; then
        # Use specified preference
        case "$prefer" in
            local)
                info "Using local (--prefer-local)"
                cmd_vault_push --force
                ;;
            vault)
                info "Using vault (--prefer-vault)"
                cmd_vault_pull --force
                ;;
        esac
        return $?
    fi

    if [[ "$force" != "true" ]]; then
        # Show diff and ask
        cmd_vault_diff
        print ""
        print "To resolve:"
        print "  ${BOLD}--prefer-local${NC}  Use local file (push to vault)"
        print "  ${BOLD}--prefer-vault${NC}  Use vault item (pull to local)"
        return 1
    fi

    # Force without preference - prefer local (safer for user data)
    warn "Force sync: preferring local file"
    cmd_vault_push --force
    return $?
}

# Main vault command dispatcher
cmd_vault() {
    local subcmd="${1:-status}"
    shift 2>/dev/null || true

    case "$subcmd" in
        push)
            cmd_vault_push "$@"
            ;;
        pull)
            cmd_vault_pull "$@"
            ;;
        diff)
            cmd_vault_diff "$@"
            ;;
        sync)
            cmd_vault_sync "$@"
            ;;
        status)
            cmd_vault_status "$@"
            ;;
        help|-h|--help)
            print "${BOLD}dotfiles template vault${NC} - Sync template variables with vault"
            print ""
            print "${CYAN}COMMANDS${NC}"
            print "    push        Push _variables.local.sh to vault"
            print "    pull        Pull from vault to _variables.local.sh"
            print "    diff        Show differences between local and vault"
            print "    sync        Bidirectional sync with conflict detection"
            print "    status      Show vault sync status (default)"
            print ""
            print "${CYAN}OPTIONS${NC}"
            print "    --force, -f       Force overwrite without confirmation"
            print "    --prefer-local    On conflict, use local file"
            print "    --prefer-vault    On conflict, use vault item"
            print "    --no-backup       Don't backup local file on pull"
            print ""
            print "${CYAN}EXAMPLES${NC}"
            print "    # First time: push local config to vault for backup"
            print "    dotfiles template vault push"
            print ""
            print "    # New machine: pull config from vault"
            print "    dotfiles template vault pull"
            print ""
            print "    # Check if in sync"
            print "    dotfiles template vault status"
            print ""
            print "    # See differences"
            print "    dotfiles template vault diff"
            print ""
            print "    # Sync with conflict resolution"
            print "    dotfiles template vault sync --prefer-local"
            ;;
        *)
            fail "Unknown vault command: $subcmd"
            print "Run 'dotfiles template vault help' for usage"
            return 1
            ;;
    esac
}

# ============================================================
# Main
# ============================================================
main() {
    local command="${1:-help}"
    shift 2>/dev/null || true

    case "$command" in
        init)
            cmd_init "$@"
            ;;
        render)
            cmd_render "$@"
            ;;
        check|validate)
            cmd_check "$@"
            ;;
        diff)
            cmd_diff "$@"
            ;;
        vars|variables)
            cmd_vars "$@"
            ;;
        filters)
            cmd_filters "$@"
            ;;
        edit)
            cmd_edit "$@"
            ;;
        link|symlink)
            cmd_link "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        arrays)
            cmd_arrays "$@"
            ;;
        vault)
            cmd_vault "$@"
            ;;
        help|-h|--help)
            usage
            ;;
        *)
            fail "Unknown command: $command"
            print "Run 'dotfiles template help' for usage"
            return 1
            ;;
    esac
}

main "$@"
