#!/usr/bin/env zsh
# ============================================================
# FILE: bin/dotfiles-hook
# Hook system management command
# Usage: dotfiles hook [command] [options]
# ============================================================
set -uo pipefail

# Determine script location
SCRIPT_DIR="$(cd "$(dirname "${0:a}")" && pwd)"
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"

# Source libraries
source "$DOTFILES_DIR/lib/_logging.sh"
source "$DOTFILES_DIR/lib/_hooks.sh"

# Try to source features (optional - for feature checks)
if [[ -f "$DOTFILES_DIR/lib/_features.sh" ]]; then
    source "$DOTFILES_DIR/lib/_features.sh"
fi

# ============================================================
# Colors
# ============================================================
GREEN="${GREEN:-\033[0;32m}"
RED="${RED:-\033[0;31m}"
YELLOW="${YELLOW:-\033[0;33m}"
CYAN="${CYAN:-\033[0;36m}"
BOLD="${BOLD:-\033[1m}"
DIM="${DIM:-\033[2m}"
NC="${NC:-\033[0m}"

# ============================================================
# Usage
# ============================================================
usage() {
    echo -e "${BOLD}Usage:${NC} dotfiles hook <command> [options]"
    echo ""
    echo -e "${BOLD}Commands:${NC}"
    echo "  list [point]          List hooks (all points or specific point)"
    echo "  run <point> [args]    Manually trigger hooks for a point"
    echo "  add <point> <script>  Add a hook script to a point"
    echo "  remove <point> <name> Remove a hook script"
    echo "  points                List all available hook points"
    echo "  test <point>          Test hooks for a point (verbose dry-run)"
    echo ""
    echo -e "${BOLD}Options:${NC}"
    echo "  --verbose, -v         Show detailed output"
    echo "  --no-hooks            Skip hook execution (for run command)"
    echo "  -h, --help            Show this help"
    echo ""
    echo -e "${BOLD}Hook Points:${NC}"
    echo -e "  ${CYAN}Lifecycle:${NC}      pre_install, post_install, pre_bootstrap, post_bootstrap,"
    echo "                  pre_upgrade, post_upgrade"
    echo -e "  ${CYAN}Vault:${NC}          pre_vault_pull, post_vault_pull, pre_vault_push, post_vault_push"
    echo -e "  ${CYAN}Doctor:${NC}         pre_doctor, post_doctor, doctor_check"
    echo -e "  ${CYAN}Shell:${NC}          shell_init, shell_exit, directory_change"
    echo -e "  ${CYAN}Setup:${NC}          pre_setup_phase, post_setup_phase, setup_complete"
    echo -e "  ${CYAN}Template:${NC}       pre_template_render, post_template_render"
    echo -e "  ${CYAN}Encryption:${NC}     pre_encrypt, post_decrypt"
    echo ""
    echo -e "${BOLD}Configuration:${NC}"
    echo -e "  Hooks directory:      ${DIM}\$HOME/.config/dotfiles/hooks/${NC}"
    echo -e "  JSON config:          ${DIM}\$HOME/.config/dotfiles/hooks.json${NC}"
    echo ""
    echo -e "${BOLD}Examples:${NC}"
    echo "  dotfiles hook list                          # List all hook points"
    echo "  dotfiles hook list post_vault_pull          # List hooks for specific point"
    echo "  dotfiles hook run post_vault_pull           # Run hooks for a point"
    echo "  dotfiles hook run --verbose post_vault_pull # Run with detailed output"
    echo "  dotfiles hook add post_vault_pull ~/my-hook.sh"
    echo "  dotfiles hook remove post_vault_pull my-hook.sh"
    echo "  dotfiles hook test post_vault_pull          # Test hooks (verbose)"
    echo ""
    echo -e "${BOLD}Hook Script Example:${NC}"
    echo -e "  ${DIM}~/.config/dotfiles/hooks/post_vault_pull/10-ssh-add.sh${NC}"
    echo "  #!/bin/bash"
    echo "  ssh-add ~/.ssh/id_ed25519 2>/dev/null"
    echo ""
    echo -e "${BOLD}JSON Config Example:${NC}"
    echo -e "  ${DIM}~/.config/dotfiles/hooks.json${NC}"
    echo '  {'
    echo '    "hooks": {'
    echo '      "post_vault_pull": ['
    echo '        {"name": "ssh-add", "command": "ssh-add ~/.ssh/id_ed25519", "enabled": true}'
    echo '      ]'
    echo '    },'
    echo '    "settings": {"fail_fast": false, "verbose": false, "timeout": 30}'
    echo '  }'
}

# ============================================================
# Commands
# ============================================================

cmd_list() {
    local point="${1:-}"

    if [[ -n "$point" ]]; then
        # Validate point
        if ! hook_valid_point "$point"; then
            fail "Invalid hook point: $point"
            echo ""
            echo "Valid hook points:"
            hook_points | sed 's/^/  /'
            return 1
        fi

        echo -e "${BOLD}Hooks for: ${CYAN}$point${NC}"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""

        local has_hooks=false

        # File-based hooks
        local hooks_dir="${HOOKS_DIR}/${point}"
        if [[ -d "$hooks_dir" ]]; then
            local scripts=("$hooks_dir"/*.{sh,zsh}(N))
            if [[ ${#scripts[@]} -gt 0 ]]; then
                echo -e "${BOLD}File-based hooks:${NC} ${DIM}($hooks_dir)${NC}"
                local script
                for script in "${scripts[@]}"; do
                    [[ -f "$script" ]] || continue
                    has_hooks=true
                    local name=$(basename "$script")
                    if [[ -x "$script" ]]; then
                        echo -e "  ${GREEN}●${NC} $name ${DIM}(executable)${NC}"
                    else
                        echo -e "  ${YELLOW}○${NC} $name ${DIM}(not executable - will be skipped)${NC}"
                    fi
                done
                echo ""
            fi
        fi

        # Registered function hooks
        local funcs="${HOOKS[$point]:-}"
        if [[ -n "$funcs" ]]; then
            echo -e "${BOLD}Registered functions:${NC}"
            has_hooks=true
            local func
            for func in ${(s: :)funcs}; do
                echo -e "  ${GREEN}●${NC} $func"
            done
            echo ""
        fi

        # JSON configured hooks
        if [[ -f "$HOOKS_CONFIG" ]] && command -v jq &>/dev/null; then
            local json_hooks
            json_hooks=$(jq -r ".hooks.\"$point\" // []" "$HOOKS_CONFIG" 2>/dev/null)
            if [[ "$json_hooks" != "[]" && "$json_hooks" != "null" ]]; then
                echo -e "${BOLD}JSON configured:${NC} ${DIM}($HOOKS_CONFIG)${NC}"
                has_hooks=true
                local count=$(echo "$json_hooks" | jq 'length')
                local i=0
                while (( i < count )); do
                    local name=$(echo "$json_hooks" | jq -r ".[$i].name // \"hook-$i\"")
                    local enabled=$(echo "$json_hooks" | jq -r ".[$i].enabled // true")
                    local cmd=$(echo "$json_hooks" | jq -r ".[$i].command // empty")
                    local script=$(echo "$json_hooks" | jq -r ".[$i].script // empty")
                    local func=$(echo "$json_hooks" | jq -r ".[$i].function // empty")

                    local type_label=""
                    [[ -n "$cmd" ]] && type_label="command"
                    [[ -n "$script" ]] && type_label="script: $script"
                    [[ -n "$func" ]] && type_label="function: $func"

                    if [[ "$enabled" == "true" ]]; then
                        echo -e "  ${GREEN}●${NC} $name ${DIM}($type_label)${NC}"
                    else
                        echo -e "  ${DIM}○${NC} $name ${DIM}(disabled, $type_label)${NC}"
                    fi
                    i=$((i + 1))
                done
                echo ""
            fi
        fi

        if ! $has_hooks; then
            echo -e "${DIM}No hooks registered for this point.${NC}"
            echo ""
            echo "Add hooks by:"
            echo "  1. Creating scripts in: $hooks_dir/"
            echo "  2. Adding to JSON config: $HOOKS_CONFIG"
            echo "  3. Calling hook_register() in your shell config"
        fi
    else
        # List all hook points with counts
        echo -e "${BOLD}Hook System${NC}"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""

        # Group by category
        local categories=(
            "Lifecycle:pre_install post_install pre_bootstrap post_bootstrap pre_upgrade post_upgrade"
            "Vault:pre_vault_pull post_vault_pull pre_vault_push post_vault_push"
            "Doctor:pre_doctor post_doctor doctor_check"
            "Shell:shell_init shell_exit directory_change"
            "Setup:pre_setup_phase post_setup_phase setup_complete"
            "Template:pre_template_render post_template_render"
            "Encryption:pre_encrypt post_decrypt"
        )

        local cat_entry cat_name cat_points p count s funcs_count json_count scripts
        for cat_entry in "${categories[@]}"; do
            cat_name="${cat_entry%%:*}"
            cat_points="${cat_entry#*:}"

            echo -e "${BOLD}${CYAN}$cat_name${NC}"
            echo "───────────────────────────────────────────────────────────────"

            for p in ${(s: :)cat_points}; do
                count=0

                # Count file-based hooks
                if [[ -d "${HOOKS_DIR}/${p}" ]]; then
                    scripts=("${HOOKS_DIR}/${p}"/*.{sh,zsh}(N))
                    for s in "${scripts[@]}"; do
                        [[ -f "$s" ]] && count=$((count + 1))
                    done
                fi

                # Count registered functions
                if [[ -n "${HOOKS[$p]:-}" ]]; then
                    funcs_count=$(echo "${HOOKS[$p]}" | wc -w)
                    count=$((count + funcs_count))
                fi

                # Count JSON hooks
                if [[ -f "$HOOKS_CONFIG" ]] && command -v jq &>/dev/null; then
                    json_count=$(jq -r ".hooks.\"$p\" | length // 0" "$HOOKS_CONFIG" 2>/dev/null || echo 0)
                    count=$((count + json_count))
                fi

                if (( count > 0 )); then
                    printf "  ${GREEN}●${NC} %-25s %d hook(s)\n" "$p" "$count"
                else
                    printf "  ${DIM}○${NC} %-25s ${DIM}no hooks${NC}\n" "$p"
                fi
            done
            echo ""
        done

        echo -e "${DIM}Use 'dotfiles hook list <point>' for details on a specific point.${NC}"
    fi
}

cmd_run() {
    local verbose=""
    local no_hooks=""

    # Parse flags
    while [[ $# -gt 0 && "$1" == -* ]]; do
        case "$1" in
            --verbose|-v) verbose="--verbose"; shift ;;
            --no-hooks) no_hooks="--no-hooks"; shift ;;
            *) shift ;;
        esac
    done

    local point="${1:-}"
    shift 2>/dev/null || true

    if [[ -z "$point" ]]; then
        fail "Hook point required"
        echo "Usage: dotfiles hook run [--verbose] <point> [args...]"
        return 1
    fi

    if ! hook_valid_point "$point"; then
        fail "Invalid hook point: $point"
        return 1
    fi

    info "Running hooks for: $point"

    if hook_run $verbose $no_hooks "$point" "$@"; then
        pass "Hooks completed successfully"
    else
        fail "One or more hooks failed"
        return 1
    fi
}

cmd_add() {
    local point="${1:-}"
    local script="${2:-}"

    if [[ -z "$point" || -z "$script" ]]; then
        fail "Both hook point and script path required"
        echo "Usage: dotfiles hook add <point> <script>"
        return 1
    fi

    if ! hook_valid_point "$point"; then
        fail "Invalid hook point: $point"
        return 1
    fi

    if [[ ! -f "$script" ]]; then
        fail "Script not found: $script"
        return 1
    fi

    # Create hooks directory if needed
    local hooks_dir="${HOOKS_DIR}/${point}"
    mkdir -p "$hooks_dir"

    # Copy script
    local basename=$(basename "$script")
    local dest="$hooks_dir/$basename"

    if [[ -f "$dest" ]]; then
        warn "Hook already exists: $dest"
        echo -n "Overwrite? [y/N] "
        read -r response
        case "$response" in
            [yY][eE][sS]|[yY]) ;;
            *) info "Cancelled"; return 0 ;;
        esac
    fi

    cp "$script" "$dest"
    chmod +x "$dest"

    pass "Added hook: $dest"
    info "Hook will run during: $point"
}

cmd_remove() {
    local point="${1:-}"
    local name="${2:-}"

    if [[ -z "$point" || -z "$name" ]]; then
        fail "Both hook point and hook name required"
        echo "Usage: dotfiles hook remove <point> <name>"
        return 1
    fi

    if ! hook_valid_point "$point"; then
        fail "Invalid hook point: $point"
        return 1
    fi

    local hook_path="${HOOKS_DIR}/${point}/${name}"

    if [[ -f "$hook_path" ]]; then
        rm "$hook_path"
        pass "Removed hook: $hook_path"
    else
        fail "Hook not found: $hook_path"
        echo ""
        echo "Available hooks in ${HOOKS_DIR}/${point}:"
        if [[ -d "${HOOKS_DIR}/${point}" ]]; then
            ls -1 "${HOOKS_DIR}/${point}" 2>/dev/null | sed 's/^/  /' || echo "  (none)"
        else
            echo "  (directory does not exist)"
        fi
        return 1
    fi
}

cmd_points() {
    echo -e "${BOLD}Available Hook Points${NC}"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""

    echo -e "${CYAN}Lifecycle Hooks${NC}"
    echo "  pre_install       Before install.sh runs"
    echo "  post_install      After install.sh completes"
    echo "  pre_bootstrap     Before bootstrap script"
    echo "  post_bootstrap    After bootstrap completes"
    echo "  pre_upgrade       Before dotfiles upgrade"
    echo "  post_upgrade      After upgrade completes"
    echo ""

    echo -e "${CYAN}Vault Hooks${NC}"
    echo "  pre_vault_pull    Before restoring secrets"
    echo "  post_vault_pull   After secrets restored (e.g., ssh-add, chmod)"
    echo "  pre_vault_push    Before syncing to vault"
    echo "  post_vault_push   After vault sync"
    echo ""

    echo -e "${CYAN}Doctor Hooks${NC}"
    echo "  pre_doctor        Before health check"
    echo "  post_doctor       After health check (e.g., report to monitoring)"
    echo "  doctor_check      During doctor (adds custom checks)"
    echo ""

    echo -e "${CYAN}Shell Hooks${NC}"
    echo "  shell_init        End of .zshrc (load project-specific config)"
    echo "  shell_exit        Shell exit via zshexit"
    echo "  directory_change  On cd via chpwd (auto-activate envs)"
    echo ""

    echo -e "${CYAN}Setup Wizard Hooks${NC}"
    echo "  pre_setup_phase   Before each wizard phase"
    echo "  post_setup_phase  After each wizard phase"
    echo "  setup_complete    After all phases done"
    echo ""

    echo -e "${CYAN}Template Hooks${NC}"
    echo "  pre_template_render   Before template rendering (auto-decrypt .age files)"
    echo "  post_template_render  After templates rendered (validation, notifications)"
    echo ""

    echo -e "${CYAN}Encryption Hooks${NC}"
    echo "  pre_encrypt       Before file encryption (custom pre-processing)"
    echo "  post_decrypt      After file decryption (permission fixes, validation)"
}

cmd_test() {
    local point="${1:-}"

    if [[ -z "$point" ]]; then
        fail "Hook point required"
        echo "Usage: dotfiles hook test <point>"
        return 1
    fi

    if ! hook_valid_point "$point"; then
        fail "Invalid hook point: $point"
        return 1
    fi

    echo -e "${BOLD}Testing hooks for: ${CYAN}$point${NC}"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""

    # Show what would run
    cmd_list "$point"

    echo "───────────────────────────────────────────────────────────────"
    echo -e "${BOLD}Executing with --verbose:${NC}"
    echo ""

    hook_run --verbose "$point"
    local result=$?

    echo ""
    if (( result == 0 )); then
        pass "All hooks completed successfully"
    else
        fail "One or more hooks failed (exit code: $result)"
    fi

    return $result
}

# ============================================================
# Main
# ============================================================

# Check if hooks feature is enabled (if feature registry available)
if type feature_enabled &>/dev/null; then
    if ! feature_enabled "hooks" 2>/dev/null; then
        warn "Hooks feature is disabled"
        echo "Enable with: dotfiles features enable hooks"
        exit 1
    fi
fi

# Parse global flags
VERBOSE=""
while [[ $# -gt 0 && "$1" == -* ]]; do
    case "$1" in
        --verbose|-v) VERBOSE="true"; shift ;;
        -h|--help) usage; exit 0 ;;
        *) break ;;
    esac
done

# Get command
COMMAND="${1:-list}"
shift 2>/dev/null || true

case "$COMMAND" in
    list|ls)        cmd_list "$@" ;;
    run)            cmd_run "$@" ;;
    add)            cmd_add "$@" ;;
    remove|rm)      cmd_remove "$@" ;;
    points)         cmd_points ;;
    test)           cmd_test "$@" ;;
    -h|--help|help) usage ;;
    *)
        fail "Unknown command: $COMMAND"
        echo "Run 'dotfiles hook --help' for usage"
        exit 1
        ;;
esac
