#!/usr/bin/env zsh
# ============================================================
# FILE: bin/dotfiles-sync
# Bidirectional sync between local files and vault
# Intelligently determines sync direction based on changes
# Usage:
#   dotfiles sync              # Interactive sync all items
#   dotfiles sync --dry-run    # Preview changes
#   dotfiles sync --force-local   # Push local to vault
#   dotfiles sync --force-vault   # Pull vault to local
# ============================================================
set -uo pipefail

# Determine script location and source libraries
SCRIPT_DIR="$(cd "$(dirname "${0:a}")" && pwd)"
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"

source "$DOTFILES_DIR/lib/_logging.sh"
source "$DOTFILES_DIR/lib/_config.sh"
source "$DOTFILES_DIR/lib/_vault.sh"
source "$DOTFILES_DIR/lib/_drift.sh"
source "$DOTFILES_DIR/vault/_common.sh"

# ============================================================
# Configuration
# ============================================================
DRY_RUN=false
FORCE_LOCAL=false
FORCE_VAULT=false
VERBOSE=false
ITEMS_TO_SYNC=()

# State tracking
DRIFT_STATE_FILE="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles/vault-state.json"

# ============================================================
# Usage
# ============================================================
usage() {
    cat <<EOF
Bidirectional sync between local files and vault

Usage: dotfiles sync [OPTIONS] [ITEMS...]

OPTIONS:
    --dry-run, -n      Show what would be synced without making changes
    --force-local, -l  Push all local changes to vault (overwrite vault)
    --force-vault, -v  Pull all vault content to local (overwrite local)
    --verbose          Show detailed comparison info
    --all, -a          Sync all syncable items
    --help, -h         Show this help

SYNC BEHAVIOR:
    By default, sync determines the correct direction for each item:
    - If local changed since last sync → push to vault
    - If vault changed since last sync → pull from vault
    - If both changed → prompt or use --force-* flag
    - If neither changed → skip (already in sync)

ITEMS:
EOF
    for item in "${(@k)SYNCABLE_ITEMS}"; do
        printf "    %-25s %s\n" "$item" "${SYNCABLE_ITEMS[$item]}"
    done | sort
    cat <<EOF

EXAMPLES:
    dotfiles sync --dry-run         # Preview all changes
    dotfiles sync --all             # Sync everything
    dotfiles sync Git-Config        # Sync just Git config
    dotfiles sync --force-local     # Push all local to vault
    dotfiles sync --force-vault     # Pull all vault to local

EOF
    exit 0
}

# ============================================================
# Parse Arguments
# ============================================================
while [[ $# -gt 0 ]]; do
    case "$1" in
        --dry-run|-n)
            DRY_RUN=true
            shift
            ;;
        --force-local|-l)
            FORCE_LOCAL=true
            shift
            ;;
        --force-vault|-v)
            FORCE_VAULT=true
            shift
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --all|-a)
            ITEMS_TO_SYNC=("${(@k)SYNCABLE_ITEMS}")
            shift
            ;;
        --help|-h)
            usage
            ;;
        -*)
            fail "Unknown option: $1"
            usage
            ;;
        *)
            if (( ${+SYNCABLE_ITEMS[$1]} )); then
                ITEMS_TO_SYNC+=("$1")
            else
                fail "Unknown item: $1"
                echo "Valid items: ${(k)SYNCABLE_ITEMS[*]}" >&2
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate conflicting flags
if [[ "$FORCE_LOCAL" == "true" && "$FORCE_VAULT" == "true" ]]; then
    fail "Cannot use --force-local and --force-vault together"
    exit 1
fi

# Default to all items if none specified
if [[ ${#ITEMS_TO_SYNC[@]} -eq 0 ]]; then
    ITEMS_TO_SYNC=("${(@k)SYNCABLE_ITEMS}")
fi

# ============================================================
# Offline Mode Check
# ============================================================
if is_offline; then
    warn "DOTFILES_OFFLINE=1 - Cannot sync in offline mode"
    echo ""
    echo "To sync later:"
    echo "  unset DOTFILES_OFFLINE"
    echo "  dotfiles sync"
    exit 0
fi

# ============================================================
# Initialize Vault
# ============================================================
section "Dotfiles Sync"

# Validate vault-items.json schema
info "Validating vault-items.json schema..."
if ! vault_validate_schema; then
    fail "Schema validation failed - cannot proceed"
    exit 1
fi
pass "Schema validation passed"

# Check vault config
require_vault_config || exit 1

# Initialize vault backend
if ! vault_init; then
    fail "Failed to initialize vault backend"
    exit 1
fi

BACKEND_NAME=$(vault_name)
info "Using vault backend: $BACKEND_NAME"

# Check login
if ! vault_login_check; then
    warn "$BACKEND_NAME not unlocked"
    echo ""
    case "$DOTFILES_VAULT_BACKEND" in
        bitwarden)
            info "Run: export BW_SESSION=\"\$(bw unlock --raw)\""
            ;;
        1password)
            info "Run: eval \$(op signin)"
            ;;
        pass)
            info "Ensure GPG agent is running"
            ;;
    esac
    exit 1
fi

# Get session
SESSION=$(vault_get_session)

# Sync vault
info "Syncing with $BACKEND_NAME..."
vault_sync "$SESSION" >/dev/null 2>&1 || true

# ============================================================
# Helper Functions
# ============================================================

# Calculate SHA256 checksum of content
calc_checksum() {
    local content="$1"
    printf '%s' "$content" | sha256sum | cut -d' ' -f1
}

# Get cached checksum for an item (from last sync)
get_cached_checksum() {
    local item_name="$1"
    if [[ -f "$DRIFT_STATE_FILE" ]]; then
        jq -r ".items[\"$item_name\"].checksum // empty" "$DRIFT_STATE_FILE" 2>/dev/null
    fi
}

# Determine sync direction for an item
# Returns: in_sync, push, pull, conflict
determine_sync_direction() {
    local item_name="$1"
    local local_path="${SYNCABLE_ITEMS[$item_name]}"

    # Get local content and checksum
    local local_content=""
    local local_checksum=""
    if [[ -f "$local_path" ]]; then
        local_content=$(cat "$local_path")
        local_checksum=$(calc_checksum "$local_content")
    fi

    # Get vault content and checksum
    local vault_content=""
    local vault_checksum=""
    vault_content=$(vault_get_notes "$item_name" "$SESSION" 2>/dev/null || echo "")
    if [[ -n "$vault_content" && "$vault_content" != "null" ]]; then
        vault_checksum=$(calc_checksum "$vault_content")
    fi

    # Get cached checksum (baseline from last sync)
    local cached_checksum=$(get_cached_checksum "$item_name")

    # Debug output
    if [[ "$VERBOSE" == "true" ]]; then
        echo "    Local checksum:  ${local_checksum:-<missing>}"
        echo "    Vault checksum:  ${vault_checksum:-<missing>}"
        echo "    Cached checksum: ${cached_checksum:-<none>}"
    fi

    # Case 1: Both match - in sync
    if [[ "$local_checksum" == "$vault_checksum" ]]; then
        echo "in_sync"
        return 0
    fi

    # Case 2: No cached state - use simple comparison
    if [[ -z "$cached_checksum" ]]; then
        # No baseline, cannot determine direction
        if [[ -z "$local_checksum" && -n "$vault_checksum" ]]; then
            echo "pull"  # Local missing, vault has content
        elif [[ -n "$local_checksum" && -z "$vault_checksum" ]]; then
            echo "push"  # Vault missing, local has content
        else
            echo "conflict"  # Both exist but differ, no baseline
        fi
        return 0
    fi

    # Case 3: Cached state exists - determine which side changed
    local local_changed=false
    local vault_changed=false

    if [[ "$local_checksum" != "$cached_checksum" ]]; then
        local_changed=true
    fi

    if [[ "$vault_checksum" != "$cached_checksum" ]]; then
        vault_changed=true
    fi

    if [[ "$local_changed" == "true" && "$vault_changed" == "false" ]]; then
        echo "push"
    elif [[ "$local_changed" == "false" && "$vault_changed" == "true" ]]; then
        echo "pull"
    elif [[ "$local_changed" == "true" && "$vault_changed" == "true" ]]; then
        echo "conflict"
    else
        # Neither changed from baseline (shouldn't happen if checksums differ)
        echo "in_sync"
    fi
}

# Push local content to vault
push_to_vault() {
    local item_name="$1"
    local local_path="${SYNCABLE_ITEMS[$item_name]}"

    if [[ ! -f "$local_path" ]]; then
        warn "Local file not found: $local_path"
        return 1
    fi

    local local_content=$(cat "$local_path")

    if $DRY_RUN; then
        dry "Would push $local_path → $BACKEND_NAME:$item_name"
        return 0
    fi

    if vault_item_exists "$item_name" "$SESSION"; then
        if vault_update_item "$item_name" "$local_content" "$SESSION"; then
            pass "Pushed $item_name to $BACKEND_NAME"
            return 0
        else
            fail "Failed to push $item_name"
            return 1
        fi
    else
        if vault_create_item "$item_name" "$local_content" "$SESSION"; then
            pass "Created $item_name in $BACKEND_NAME"
            return 0
        else
            fail "Failed to create $item_name"
            return 1
        fi
    fi
}

# Pull vault content to local
pull_from_vault() {
    local item_name="$1"
    local local_path="${SYNCABLE_ITEMS[$item_name]}"

    local vault_content=$(vault_get_notes "$item_name" "$SESSION" 2>/dev/null)

    if [[ -z "$vault_content" || "$vault_content" == "null" ]]; then
        warn "No content in vault for $item_name"
        return 1
    fi

    if $DRY_RUN; then
        dry "Would pull $BACKEND_NAME:$item_name → $local_path"
        return 0
    fi

    # Create directory if needed
    local parent_dir=$(dirname "$local_path")
    mkdir -p "$parent_dir"

    # Backup existing file
    if [[ -f "$local_path" ]]; then
        cp "$local_path" "${local_path}.bak" 2>/dev/null || true
    fi

    # Write content with proper permissions
    if printf '%s' "$vault_content" > "$local_path"; then
        chmod 600 "$local_path"
        pass "Pulled $item_name to $local_path"
        return 0
    else
        fail "Failed to write $local_path"
        return 1
    fi
}

# ============================================================
# Main Sync Logic
# ============================================================
echo ""
echo "========================================"
echo "Syncing ${#ITEMS_TO_SYNC[@]} items with $BACKEND_NAME"
if $DRY_RUN; then
    echo -e "${CYAN}(DRY RUN - no changes will be made)${NC}"
fi
if $FORCE_LOCAL; then
    echo -e "${YELLOW}(FORCE LOCAL - pushing all to vault)${NC}"
fi
if $FORCE_VAULT; then
    echo -e "${YELLOW}(FORCE VAULT - pulling all from vault)${NC}"
fi
echo "========================================"
echo ""

# Counters
PUSHED=0
PULLED=0
IN_SYNC=0
CONFLICTS=0
FAILED=0

for item_name in "${ITEMS_TO_SYNC[@]}"; do
    echo -e "${BLUE}--- $item_name ---${NC}"
    local_path="${SYNCABLE_ITEMS[$item_name]}"
    echo "    Local: $local_path"

    # Determine direction
    if $FORCE_LOCAL; then
        direction="push"
    elif $FORCE_VAULT; then
        direction="pull"
    else
        direction=$(determine_sync_direction "$item_name")
    fi

    case "$direction" in
        in_sync)
            pass "Already in sync"
            IN_SYNC=$((IN_SYNC + 1))
            ;;
        push)
            info "Local → Vault"
            if push_to_vault "$item_name"; then
                PUSHED=$((PUSHED + 1))
            else
                FAILED=$((FAILED + 1))
            fi
            ;;
        pull)
            info "Vault → Local"
            if pull_from_vault "$item_name"; then
                PULLED=$((PULLED + 1))
            else
                FAILED=$((FAILED + 1))
            fi
            ;;
        conflict)
            warn "CONFLICT: Both local and vault have changed"
            echo "    Use --force-local to push local to vault"
            echo "    Use --force-vault to pull vault to local"
            CONFLICTS=$((CONFLICTS + 1))
            ;;
    esac
    echo ""
done

# ============================================================
# Summary
# ============================================================
echo "========================================"
if $DRY_RUN; then
    echo -e "${CYAN}DRY RUN SUMMARY:${NC}"
    echo "  Would push:  $PUSHED"
    echo "  Would pull:  $PULLED"
else
    echo "SYNC SUMMARY:"
    echo "  Pushed to vault:    $PUSHED"
    echo "  Pulled from vault:  $PULLED"
fi
echo "  Already in sync:    $IN_SYNC"
if [[ $CONFLICTS -gt 0 ]]; then
    echo -e "  ${YELLOW}Conflicts:            $CONFLICTS${NC}"
fi
if [[ $FAILED -gt 0 ]]; then
    echo -e "  ${RED}Failed:               $FAILED${NC}"
fi
echo "========================================"

# Update drift state after successful sync
if ! $DRY_RUN && [[ $PUSHED -gt 0 || $PULLED -gt 0 ]]; then
    info "Updating drift state..."
    drift_save_state

    # Update timestamps
    TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date +"%Y-%m-%dT%H:%M:%S" 2>/dev/null || echo "")
    if [[ -n "$TIMESTAMP" ]]; then
        if [[ $PUSHED -gt 0 ]]; then
            config_set "vault.last_push" "$TIMESTAMP" 2>/dev/null || true
        fi
        if [[ $PULLED -gt 0 ]]; then
            config_set "vault.last_pull" "$TIMESTAMP" 2>/dev/null || true
        fi
        config_set "vault.last_sync" "$TIMESTAMP" 2>/dev/null || true
    fi
fi

# Provide guidance for conflicts
if [[ $CONFLICTS -gt 0 ]]; then
    echo ""
    echo "To resolve conflicts:"
    echo "  dotfiles sync --force-local   # Push your local changes"
    echo "  dotfiles sync --force-vault   # Pull vault changes"
    echo "  dotfiles drift                # See detailed differences"
fi

# Exit with error if any failures
if [[ $FAILED -gt 0 ]]; then
    exit 1
fi

# Exit with warning status if conflicts
if [[ $CONFLICTS -gt 0 && "$FORCE_LOCAL" == "false" && "$FORCE_VAULT" == "false" ]]; then
    exit 2
fi

exit 0
