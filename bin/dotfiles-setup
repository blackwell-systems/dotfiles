#!/usr/bin/env zsh
# ============================================================
# FILE: bin/dotfiles-setup
# Unified interactive setup wizard for dotfiles
# Usage: dotfiles setup [--reset] [--status]
# ============================================================
set -uo pipefail

# Determine script location
SCRIPT_DIR="$(cd "$(dirname "${0:a}")" && pwd)"
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"

# Source libraries
source "$DOTFILES_DIR/lib/_logging.sh"
source "$DOTFILES_DIR/lib/_state.sh"
source "$DOTFILES_DIR/lib/_vault.sh"

# ============================================================
# Configuration
# ============================================================

FORCE_RESET=false
STATUS_ONLY=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --reset|-r)
            FORCE_RESET=true
            shift
            ;;
        --status|-s)
            STATUS_ONLY=true
            shift
            ;;
        --help|-h)
            cat << 'EOF'
Dotfiles Setup - Unified configuration wizard

Usage: dotfiles setup [OPTIONS]

Options:
  --status, -s    Show current setup status only
  --reset, -r     Reset state and re-run setup from beginning
  --help, -h      Show this help

The setup wizard will:
  1. Check current configuration status
  2. Guide you through any pending setup steps
  3. Save your preferences for future sessions

Your progress is saved automatically. If interrupted, just
run 'dotfiles setup' again to continue where you left off.
EOF
            exit 0
            ;;
        *)
            warn "Unknown option: $1"
            shift
            ;;
    esac
done

# ============================================================
# Display Functions
# ============================================================

show_banner() {
    echo ""
    echo -e "${BOLD}${CYAN}"
    cat << 'EOF'
    ____        __  _____ __
   / __ \____  / /_/ __(_) /__  _____
  / / / / __ \/ __/ /_/ / / _ \/ ___/
 / /_/ / /_/ / /_/ __/ / /  __(__  )
/_____/\____/\__/_/ /_/_/\___/____/

              Setup Wizard
EOF
    echo -e "${NC}"
}

show_status() {
    echo ""
    echo -e "${BOLD}Current Status:${NC}"
    echo "───────────────"

    local phases=("symlinks" "packages" "vault" "secrets" "claude" "template")
    local labels=("Symlinks" "Packages" "Vault" "Secrets" "Claude" "Templates")
    local details=("Shell config linked" "Homebrew packages" "Vault backend" "SSH keys, AWS, Git" "Claude Code integration" "Machine-specific configs")

    for i in {1..${#phases[@]}}; do
        local phase="${phases[$i]}"
        local label="${labels[$i]}"
        local detail="${details[$i]}"

        if state_completed "$phase"; then
            # Special handling for vault to show if skipped
            if [[ "$phase" == "vault" ]]; then
                local backend=$(config_get "vault" "backend" "")
                if [[ "$backend" == "none" ]]; then
                    echo -e "  ${YELLOW}[⊘]${NC} $label ${DIM}(Skipped - run 'dotfiles vault init')${NC}"
                else
                    echo -e "  ${GREEN}[✓]${NC} $label ${DIM}($detail: ${backend:-unknown})${NC}"
                fi
            else
                echo -e "  ${GREEN}[✓]${NC} $label ${DIM}($detail)${NC}"
            fi
        else
            echo -e "  ${YELLOW}[ ]${NC} $label ${DIM}($detail)${NC}"
        fi
    done

    echo ""
}

# ============================================================
# Setup Phases
# ============================================================

phase_symlinks() {
    echo ""
    echo -e "${BOLD}${CYAN}STEP 1: Symlinks${NC}"
    echo "─────────────────"

    if state_completed "symlinks"; then
        pass "Symlinks already configured"
        return 0
    fi

    echo "This will link your shell configuration files."
    echo ""
    echo "Files to link:"
    echo "  ~/.zshrc     → $DOTFILES_DIR/zsh/zshrc"
    echo "  ~/.p10k.zsh  → $DOTFILES_DIR/zsh/p10k.zsh"
    echo ""

    echo -n "Create symlinks? [Y/n]: "
    read confirm
    if [[ "${confirm:-Y}" =~ ^[Nn]$ ]]; then
        warn "Skipped symlinks"
        return 1
    fi

    # Run symlink creation
    if [[ -f "$DOTFILES_DIR/bootstrap/bootstrap-dotfiles.sh" ]]; then
        "$DOTFILES_DIR/bootstrap/bootstrap-dotfiles.sh"
        state_complete "symlinks"
        pass "Symlinks created"
    else
        fail "bootstrap-dotfiles.sh not found"
        return 1
    fi
}

phase_packages() {
    echo ""
    echo -e "${BOLD}${CYAN}STEP 2: Packages${NC}"
    echo "─────────────────"

    if state_completed "packages"; then
        pass "Packages already installed"
        return 0
    fi

    # Check if Homebrew is available
    if ! command -v brew &>/dev/null; then
        warn "Homebrew not installed - skipping package installation"
        echo "Install Homebrew and run 'dotfiles packages' later."
        return 0
    fi

    echo "This will install packages from Brewfile."
    echo ""

    echo -n "Install packages? [Y/n]: "
    read confirm
    if [[ "${confirm:-Y}" =~ ^[Nn]$ ]]; then
        warn "Skipped packages"
        return 0
    fi

    info "Running brew bundle..."
    if (cd "$DOTFILES_DIR" && brew bundle); then
        state_complete "packages"
        pass "Packages installed"
    else
        warn "Some packages may have failed - continuing"
        state_complete "packages"
    fi
}

phase_vault() {
    echo ""
    echo -e "${BOLD}${CYAN}STEP 3: Vault Configuration${NC}"
    echo "────────────────────────────"

    if state_completed "vault"; then
        local backend=$(config_get "vault" "backend" "")
        if [[ -n "$backend" ]] && [[ "$backend" != "none" ]]; then
            pass "Vault already configured ($backend)"
        elif [[ "$backend" == "none" ]]; then
            warn "Vault was skipped previously"
        else
            pass "Vault already configured"
        fi

        echo ""
        echo -n "Reconfigure vault? [y/N]: "
        read reconfigure
        if [[ "${reconfigure}" =~ ^[Yy]$ ]]; then
            info "Reconfiguring vault..."
            state_reset "vault"
            # Fall through to configuration below
        else
            if [[ "$backend" == "none" ]]; then
                info "Run 'dotfiles vault init' anytime to configure vault"
            fi
            return 0
        fi
    fi

    # Detect available vault backends
    local available=()
    if command -v bw &>/dev/null; then
        available+=("bitwarden")
    fi
    if command -v op &>/dev/null; then
        available+=("1password")
    fi
    if command -v pass &>/dev/null; then
        available+=("pass")
    fi

    if [[ ${#available[@]} -eq 0 ]]; then
        echo "No vault CLI detected. Vault features are optional."
        echo ""
        echo "Supported vault backends:"
        echo "  • Bitwarden:  brew install bitwarden-cli"
        echo "  • 1Password:  brew install 1password-cli"
        echo "  • pass:       brew install pass"
        echo ""
        echo -n "Skip vault setup? [Y/n]: "
        read skip
        if [[ "${skip:-Y}" =~ ^[Yy]$ ]]; then
            warn "Skipped vault setup"
            config_set "vault" "backend" "none"
            state_complete "vault"
            echo ""
            info "Run 'dotfiles vault init' anytime to configure vault"
            return 0
        else
            echo "Please install a vault CLI and run 'dotfiles setup' again."
            return 1
        fi
    fi

    echo "Available vault backends:"
    for i in {1..${#available[@]}}; do
        echo "  $i) ${available[$i]}"
    done
    echo "  $((${#available[@]} + 1))) Skip (configure secrets manually)"
    echo ""

    echo -n "Select vault backend [1]: "
    read choice
    choice=${choice:-1}

    # Check if user chose to skip
    if [[ $choice -eq $((${#available[@]} + 1)) ]]; then
        warn "Skipped vault setup"
        config_set "vault" "backend" "none"
        state_complete "vault"
        echo ""
        info "Run 'dotfiles vault init' anytime to configure vault"
        return 0
    fi

    local selected="${available[$choice]}"
    if [[ -z "$selected" ]]; then
        fail "Invalid selection"
        return 1
    fi

    # Save preference
    config_set "vault" "backend" "$selected"
    export DOTFILES_VAULT_BACKEND="$selected"

    info "Using vault backend: $selected"
    echo ""

    # Check/create vault items configuration
    local vault_config="${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/vault-items.json"
    local vault_example="$DOTFILES_DIR/vault/vault-items.example.json"

    if [[ ! -f "$vault_config" ]]; then
        echo "Vault items configuration needed."
        echo ""
        echo "This config defines which secrets to manage:"
        echo "  • SSH keys (names and paths)"
        echo "  • Config files (AWS, Git, etc.)"
        echo ""

        # Create config directory
        mkdir -p "$(dirname "$vault_config")"

        # Copy example
        if [[ -f "$vault_example" ]]; then
            cp "$vault_example" "$vault_config"
            pass "Created $vault_config"
            echo ""
            echo "Please customize your vault items configuration."
            echo "Edit the file to match your vault item names and paths."
            echo ""
            echo -n "Open editor now? [Y/n]: "
            read edit_now
            if [[ "${edit_now:-Y}" =~ ^[Yy]$ ]]; then
                ${EDITOR:-vim} "$vault_config"
            fi
        else
            fail "Example config not found: $vault_example"
            return 1
        fi
    else
        pass "Vault items config exists"
    fi
    echo ""

    # Backend-specific login
    case "$selected" in
        bitwarden)
            if ! bw login --check &>/dev/null; then
                echo "Log in to Bitwarden:"
                bw login || { fail "Bitwarden login failed"; return 1; }
            fi

            if ! bw unlock --check &>/dev/null 2>&1; then
                echo ""
                echo "Unlock your vault:"
                local session=$(bw unlock --raw)
                if [[ -n "$session" ]]; then
                    export BW_SESSION="$session"
                    # Cache session
                    echo "$session" > "$DOTFILES_DIR/vault/.vault-session"
                    chmod 600 "$DOTFILES_DIR/vault/.vault-session"
                    pass "Vault unlocked"
                else
                    fail "Failed to unlock vault"
                    return 1
                fi
            else
                pass "Vault already unlocked"
            fi
            ;;

        1password)
            if ! op account list &>/dev/null 2>&1; then
                echo "Sign in to 1Password:"
                eval $(op signin) || { fail "1Password signin failed"; return 1; }
            fi
            pass "1Password authenticated"
            ;;

        pass)
            # Note: 'pass' is both a command and our logging function
            # Use command pass to call the actual pass CLI
            if command pass ls &>/dev/null 2>&1; then
                pass "pass accessible (GPG agent active)"
            else
                warn "pass not accessible - check GPG configuration"
                echo "You may need to:"
                echo "  • Import your GPG key"
                echo "  • Initialize pass: pass init <gpg-key-id>"
                return 1
            fi
            ;;
    esac

    state_complete "vault"
    pass "Vault configured"
}

phase_secrets() {
    echo ""
    echo -e "${BOLD}${CYAN}STEP 4: Secrets Management${NC}"
    echo "───────────────────────────"

    if state_completed "secrets"; then
        pass "Secrets already configured"
        return 0
    fi

    local backend=$(config_get "vault" "backend" "none")
    if [[ "$backend" == "none" ]]; then
        warn "Vault not configured - skipping secrets"
        echo "Configure secrets manually in ~/.ssh, ~/.aws, ~/.gitconfig"
        state_complete "secrets"
        return 0
    fi

    # Source vault common to get SYNCABLE_ITEMS
    source "$DOTFILES_DIR/vault/_common.sh"

    # Require vault config
    if ! require_vault_config; then
        fail "Cannot manage secrets without vault config"
        return 1
    fi

    # Detect local secrets and vault state
    local local_exists=()
    local vault_exists=()
    local local_only=()
    local vault_only=()
    local both_exist=()

    echo "Scanning secrets..."
    echo ""

    # Get vault session
    local session
    session=$(get_session 2>/dev/null) || true

    # Check each syncable item
    for item_name in "${(@k)SYNCABLE_ITEMS}"; do
        local local_path="${SYNCABLE_ITEMS[$item_name]}"
        local has_local=false
        local has_vault=false

        # Check local file
        if [[ -f "$local_path" ]]; then
            has_local=true
            local_exists+=("$item_name")
        fi

        # Check vault (if session available)
        if [[ -n "$session" ]] && vault_item_exists "$item_name" "$session" 2>/dev/null; then
            has_vault=true
            vault_exists+=("$item_name")
        fi

        # Categorize
        if $has_local && ! $has_vault; then
            local_only+=("$item_name")
        elif ! $has_local && $has_vault; then
            vault_only+=("$item_name")
        elif $has_local && $has_vault; then
            both_exist+=("$item_name")
        fi
    done

    # Also check SSH keys
    for item_name in "${(@k)SSH_KEYS}"; do
        local local_path="${SSH_KEYS[$item_name]}"
        local has_local=false
        local has_vault=false

        if [[ -f "$local_path" ]]; then
            has_local=true
        fi

        if [[ -n "$session" ]] && vault_item_exists "$item_name" "$session" 2>/dev/null; then
            has_vault=true
        fi

        if $has_local && ! $has_vault; then
            local_only+=("$item_name")
        elif ! $has_local && $has_vault; then
            vault_only+=("$item_name")
        elif $has_local && $has_vault; then
            both_exist+=("$item_name")
        fi
    done

    # Display status
    echo -e "${BOLD}Secrets Status:${NC}"
    echo ""

    if [[ ${#local_only[@]} -gt 0 ]]; then
        echo -e "  ${YELLOW}Local only (not in vault):${NC}"
        for item in "${local_only[@]}"; do
            local path="${SYNCABLE_ITEMS[$item]:-${SSH_KEYS[$item]:-}}"
            echo "    • $item → $path"
        done
        echo ""
    fi

    if [[ ${#vault_only[@]} -gt 0 ]]; then
        echo -e "  ${CYAN}Vault only (can restore):${NC}"
        for item in "${vault_only[@]}"; do
            echo "    • $item"
        done
        echo ""
    fi

    if [[ ${#both_exist[@]} -gt 0 ]]; then
        echo -e "  ${GREEN}Synced (local + vault):${NC}"
        for item in "${both_exist[@]}"; do
            echo "    • $item"
        done
        echo ""
    fi

    # Offer to PUSH local secrets to vault
    if [[ ${#local_only[@]} -gt 0 ]]; then
        echo -e "${BOLD}${YELLOW}Found ${#local_only[@]} local secret(s) not in vault.${NC}"
        echo "Push these to $backend so you can restore on other machines."
        echo ""
        echo -n "Push local secrets to vault? [Y/n]: "
        read push_confirm
        if [[ "${push_confirm:-Y}" =~ ^[Yy]$ ]]; then
            echo ""
            local push_success=0
            local push_fail=0
            for item in "${local_only[@]}"; do
                echo -n "  Creating $item... "
                if "$DOTFILES_DIR/vault/create-vault-item.sh" "$item" 2>/dev/null; then
                    echo -e "${GREEN}done${NC}"
                    ((push_success++))
                else
                    echo -e "${RED}failed${NC}"
                    ((push_fail++))
                fi
            done
            echo ""
            if [[ $push_success -gt 0 ]]; then
                pass "Pushed $push_success secret(s) to vault"
            fi
            if [[ $push_fail -gt 0 ]]; then
                warn "$push_fail secret(s) failed to push"
            fi
        else
            info "Skipped pushing local secrets"
        fi
        echo ""
    fi

    # Offer to RESTORE from vault
    if [[ ${#vault_only[@]} -gt 0 ]]; then
        echo -e "${BOLD}${CYAN}Found ${#vault_only[@]} secret(s) in vault to restore.${NC}"
        echo ""
        echo -n "Restore secrets from vault? [Y/n]: "
        read restore_confirm
        if [[ "${restore_confirm:-Y}" =~ ^[Yy]$ ]]; then
            if "$DOTFILES_DIR/vault/restore.sh" --force; then
                pass "Secrets restored from vault"
            else
                warn "Some secrets may have failed to restore"
            fi
        else
            info "Skipped restoring from vault"
        fi
        echo ""
    fi

    # If nothing to do
    if [[ ${#local_only[@]} -eq 0 && ${#vault_only[@]} -eq 0 ]]; then
        if [[ ${#both_exist[@]} -gt 0 ]]; then
            pass "All secrets are already synced"
        else
            info "No secrets configured yet"
            echo "Add secrets to your local machine, then run 'dotfiles vault sync --all'"
        fi
    fi

    state_complete "secrets"
    pass "Secrets phase complete"
}

phase_claude() {
    echo ""
    echo -e "${BOLD}${CYAN}STEP 5: Claude Code (Optional)${NC}"
    echo "───────────────────────────────"

    if state_completed "claude"; then
        pass "Claude Code already configured"
        return 0
    fi

    # Check if Claude is installed
    if ! command -v claude &>/dev/null; then
        info "Claude Code not detected - skipping"
        state_complete "claude"
        return 0
    fi

    # Check if dotclaude is installed
    if command -v dotclaude &>/dev/null; then
        pass "dotclaude already installed"
        state_complete "claude"
        return 0
    fi

    echo "Claude Code detected. dotclaude helps manage profiles across machines."
    echo ""
    echo -n "Install dotclaude? [Y/n]: "
    read response

    if [[ "${response:-Y}" =~ ^[Yy]$ ]]; then
        info "Installing dotclaude..."
        if curl -fsSL https://raw.githubusercontent.com/blackwell-systems/dotclaude/main/install.sh | bash; then
            pass "dotclaude installed"
        else
            warn "dotclaude installation failed - continuing"
        fi
    else
        info "Skipped dotclaude installation"
    fi

    state_complete "claude"
}

phase_template() {
    echo ""
    echo -e "${BOLD}${CYAN}STEP 6: Machine-Specific Templates (Optional)${NC}"
    echo "───────────────────────────────────────────────"

    if state_completed "template"; then
        pass "Templates already configured"
        return 0
    fi

    echo "Templates let you customize configs per machine (gitconfig, ssh-config, etc.)."
    echo ""
    echo "Examples:"
    echo "  • Work vs personal git email"
    echo "  • Different SSH keys per machine"
    echo "  • Machine-specific environment variables"
    echo ""
    echo -n "Setup machine-specific config templates? [y/N]: "
    read response

    if [[ "${response}" =~ ^[Yy]$ ]]; then
        info "Initializing template system..."
        echo ""

        # Run template init interactively
        if "$DOTFILES_DIR/bin/dotfiles-template" init; then
            pass "Templates configured"
            echo ""
            info "Run 'dotfiles template render' to generate configs from your templates"
        else
            warn "Template initialization skipped or failed"
        fi
    else
        info "Skipped template setup"
        echo ""
        info "You can enable templates later with: dotfiles template init"
    fi

    state_complete "template"
}

# ============================================================
# Main Flow
# ============================================================

main() {
    # Initialize state
    state_init

    # Infer state for existing installations
    state_infer

    # Handle --status flag
    if $STATUS_ONLY; then
        show_status
        exit 0
    fi

    # Handle --reset flag
    if $FORCE_RESET; then
        echo -n "Reset all setup progress? [y/N]: "
        read confirm
        if [[ "${confirm:-N}" =~ ^[Yy]$ ]]; then
            for phase in symlinks packages vault secrets claude template; do
                state_reset "$phase"
            done
            pass "State reset"
        else
            info "Reset cancelled"
            exit 0
        fi
    fi

    show_banner
    show_status

    # Check if setup is needed
    if ! state_needs_setup; then
        echo -e "${GREEN}${BOLD}All setup complete!${NC}"
        echo ""
        echo "Run 'dotfiles doctor' to verify health."
        echo "Run 'dotfiles setup --reset' to reconfigure."
        exit 0
    fi

    echo "Let's complete your setup..."
    echo ""

    # Run each phase
    local phases=("symlinks" "packages" "vault" "secrets" "claude" "template")
    local phase_funcs=("phase_symlinks" "phase_packages" "phase_vault" "phase_secrets" "phase_claude" "phase_template")

    for i in {1..${#phases[@]}}; do
        local phase="${phases[$i]}"
        local func="${phase_funcs[$i]}"

        if ! state_completed "$phase"; then
            $func || true  # Continue even if phase fails
        fi
    done

    # Final status
    echo ""
    echo "═══════════════════════════════════════════════════════"
    show_status

    if ! state_needs_setup; then
        echo -e "${GREEN}${BOLD}Setup complete!${NC}"
        echo ""
        echo "Quick commands:"
        echo "  dotfiles status   - Visual dashboard"
        echo "  dotfiles doctor   - Health check"
        echo "  dotfiles help     - All commands"
    else
        echo -e "${YELLOW}Some steps were skipped or failed.${NC}"
        echo "Run 'dotfiles setup' again to continue."
    fi

    echo ""
}

# Run main
main "$@"
