#!/usr/bin/env zsh
# ============================================================
# FILE: bin/dotfiles-setup
# Unified interactive setup wizard for dotfiles
# Usage: dotfiles setup [--reset] [--status]
# ============================================================
set -uo pipefail

# Determine script location
SCRIPT_DIR="$(cd "$(dirname "${0:a}")" && pwd)"
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"

# Source libraries
source "$DOTFILES_DIR/lib/_logging.sh"
source "$DOTFILES_DIR/lib/_config.sh"
source "$DOTFILES_DIR/lib/_features.sh"
source "$DOTFILES_DIR/lib/_state.sh"
source "$DOTFILES_DIR/lib/_vault.sh"

# ============================================================
# Configuration
# ============================================================

FORCE_RESET=false
STATUS_ONLY=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --reset|-r)
            FORCE_RESET=true
            shift
            ;;
        --status|-s)
            STATUS_ONLY=true
            shift
            ;;
        --help|-h)
            cat << 'EOF'
Dotfiles Setup - Unified configuration wizard

Usage: dotfiles setup [OPTIONS]

Options:
  --status, -s    Show current setup status only
  --reset, -r     Reset state and re-run setup from beginning
  --help, -h      Show this help

The setup wizard will:
  1. Check current configuration status
  2. Guide you through any pending setup steps
  3. Save your preferences for future sessions

Your progress is saved automatically. If interrupted, just
run 'dotfiles setup' again to continue where you left off.
EOF
            exit 0
            ;;
        *)
            warn "Unknown option: $1"
            shift
            ;;
    esac
done

# ============================================================
# Display Functions
# ============================================================

# Show progress bar with current step
# Usage: show_progress <current_step> <total_steps> <step_name>
show_progress() {
    local current=$1
    local total=$2
    local step_name="$3"

    # Guard against division by zero
    if [[ $total -eq 0 ]]; then
        warn "Invalid progress: total=0"
        return 1
    fi

    # Guard against overflow (current > total)
    if [[ $current -gt $total ]]; then
        current=$total
    fi

    local percent=$((current * 100 / total))
    local filled=$((current * 20 / total))

    # Clamp filled to max 20 (in case of rounding issues)
    [[ $filled -gt 20 ]] && filled=20

    local empty=$((20 - filled))

    # Ensure empty is never negative
    [[ $empty -lt 0 ]] && empty=0

    # Build progress bar
    local bar=""
    for ((i=0; i<filled; i++)); do
        bar+="‚ñà"
    done
    for ((i=0; i<empty; i++)); do
        bar+="‚ñë"
    done

    echo ""
    echo -e "${BOLD}${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${BOLD}${CYAN}‚ïë${NC} ${BOLD}Step $current of $total: $step_name${NC}"
    echo -e "${BOLD}${CYAN}‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£${NC}"
    echo -e "${BOLD}${CYAN}‚ïë${NC} ${bar} ${BOLD}${percent}%${NC}"
    echo -e "${BOLD}${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
}

# Show all steps overview at the beginning
show_steps_overview() {
    echo ""
    echo -e "${BOLD}${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${BOLD}                    Setup Wizard Overview${NC}"
    echo -e "${BOLD}${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""
    echo -e "${BOLD}This wizard will guide you through 7 steps:${NC}"
    echo ""
    echo -e "  ${CYAN}1.${NC} ${BOLD}Workspace${NC}         - Configure workspace directory"
    echo -e "     ${DIM}Default: ~/workspace (target for /workspace symlink)${NC}"
    echo ""
    echo -e "  ${CYAN}2.${NC} ${BOLD}Symlinks${NC}          - Link shell config files"
    echo -e "     ${DIM}~/.zshrc, ~/.p10k.zsh, ~/.claude${NC}"
    echo ""
    echo -e "  ${CYAN}3.${NC} ${BOLD}Packages${NC}          - Install Homebrew packages"
    echo -e "     ${DIM}Choose: minimal (18) | enhanced (43) | full (61)${NC}"
    echo ""
    echo -e "  ${CYAN}4.${NC} ${BOLD}Vault${NC}             - Configure secret backend"
    echo -e "     ${DIM}Bitwarden, 1Password, or pass${NC}"
    echo ""
    echo -e "  ${CYAN}5.${NC} ${BOLD}Secrets${NC}           - Manage SSH keys, AWS, Git config"
    echo -e "     ${DIM}Auto-discover and sync to vault${NC}"
    echo ""
    echo -e "  ${CYAN}6.${NC} ${BOLD}Claude Code${NC}       - AI assistant integration"
    echo -e "     ${DIM}Optional: dotclaude + portable sessions${NC}"
    echo ""
    echo -e "  ${CYAN}7.${NC} ${BOLD}Templates${NC}         - Machine-specific configs"
    echo -e "     ${DIM}Optional: work vs personal configs${NC}"
    echo ""
    echo -e "${BOLD}${GREEN}‚úì${NC} ${BOLD}Safe to exit anytime${NC} - Progress is saved automatically"
    echo -e "${BOLD}${GREEN}‚úì${NC} ${BOLD}Resume anytime${NC} - Just run 'dotfiles setup' again"
    echo ""
    echo -e "${BOLD}${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""

    # Prompt to continue
    echo -n "Press Enter to begin setup..."
    read
}

show_banner() {
    echo ""
    echo -e "${BOLD}${CYAN}"
    cat << 'EOF'
    ____        __  _____ __
   / __ \____  / /_/ __(_) /__  _____
  / / / / __ \/ __/ /_/ / / _ \/ ___/
 / /_/ / /_/ / /_/ __/ / /  __(__  )
/_____/\____/\__/_/ /_/_/\___/____/

              Setup Wizard
EOF
    echo -e "${NC}"
}

show_status() {
    echo ""
    echo -e "${BOLD}Current Status:${NC}"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

    local phases=("workspace" "symlinks" "packages" "vault" "secrets" "claude" "template")
    local labels=("Workspace" "Symlinks" "Packages" "Vault" "Secrets" "Claude" "Templates")
    local details=("Workspace directory" "Shell config linked" "Homebrew packages" "Vault backend" "SSH keys, AWS, Git" "Claude Code integration" "Machine-specific configs")

    for i in {1..${#phases[@]}}; do
        local phase="${phases[$i]}"
        local label="${labels[$i]}"
        local detail="${details[$i]}"

        if state_completed "$phase"; then
            # Special handling for workspace to show target
            if [[ "$phase" == "workspace" ]]; then
                local ws_target=$(config_get "paths.workspace_target" "$HOME/workspace")
                echo -e "  ${GREEN}[‚úì]${NC} $label ${DIM}(‚Üí $ws_target)${NC}"
            # Special handling for vault to show if skipped
            elif [[ "$phase" == "vault" ]]; then
                local backend=$(config_get "vault.backend" "")
                if [[ "$backend" == "none" ]]; then
                    echo -e "  ${YELLOW}[‚äò]${NC} $label ${DIM}(Skipped - run 'dotfiles vault init')${NC}"
                else
                    echo -e "  ${GREEN}[‚úì]${NC} $label ${DIM}($detail: ${backend:-unknown})${NC}"
                fi
            else
                echo -e "  ${GREEN}[‚úì]${NC} $label ${DIM}($detail)${NC}"
            fi
        else
            echo -e "  ${YELLOW}[ ]${NC} $label ${DIM}($detail)${NC}"
        fi
    done

    echo ""
}

# ============================================================
# Setup Phases
# ============================================================

phase_workspace() {
    show_progress 1 7 "Workspace Configuration"

    if state_completed "workspace"; then
        local current_target=$(config_get "paths.workspace_target" "$HOME/workspace")
        pass "Workspace already configured: $current_target"
        echo ""
        echo -n "Reconfigure workspace target? [y/N]: "
        read reconfigure
        if [[ "${reconfigure}" =~ ^[Yy]$ ]]; then
            state_reset "workspace"
            # Fall through to configuration
        else
            return 0
        fi
    fi

    # Get current/default workspace target
    local default_target="${WORKSPACE_TARGET:-$HOME/workspace}"
    # Expand tilde if present
    default_target="${default_target/#\~/$HOME}"

    echo "The workspace directory is where dotfiles and projects are stored."
    echo "The /workspace symlink will point to this directory for Claude Code portability."
    echo ""
    echo "Current target: $default_target"
    echo ""
    echo "Examples:"
    echo "  ~/workspace     (default)"
    echo "  ~/code"
    echo "  ~/dev"
    echo "  ~/projects"
    echo ""
    echo -n "Workspace directory [$default_target]: "
    read user_target

    # Use default if empty
    local final_target="${user_target:-$default_target}"

    # Expand tilde if user entered one
    final_target="${final_target/#\~/$HOME}"

    # Save to config
    config_set "paths.workspace_target" "$final_target"

    # Create the directory if it doesn't exist
    if [[ ! -d "$final_target" ]]; then
        echo ""
        echo -n "Directory doesn't exist. Create it? [Y/n]: "
        read create_dir
        if [[ "${create_dir:-Y}" =~ ^[Yy]$ ]]; then
            mkdir -p "$final_target"
            pass "Created $final_target"
        fi
    fi

    # Check/update /workspace symlink
    if [[ -L "/workspace" ]]; then
        local current_link=$(readlink /workspace)
        if [[ "$current_link" != "$final_target" ]]; then
            echo ""
            info "Current /workspace ‚Üí $current_link"
            echo -n "Update symlink to ‚Üí $final_target? [Y/n]: "
            read update_link
            if [[ "${update_link:-Y}" =~ ^[Yy]$ ]]; then
                if sudo ln -sfn "$final_target" /workspace; then
                    pass "Updated /workspace ‚Üí $final_target"
                else
                    warn "Failed to update symlink (may need sudo permissions)"
                fi
            fi
        else
            pass "Symlink /workspace ‚Üí $final_target already correct"
        fi
    elif [[ ! -e "/workspace" ]]; then
        echo ""
        echo -n "Create /workspace symlink to $final_target? [Y/n]: "
        read create_link
        if [[ "${create_link:-Y}" =~ ^[Yy]$ ]]; then
            if sudo ln -sfn "$final_target" /workspace; then
                pass "Created /workspace ‚Üí $final_target"
            else
                warn "Failed to create symlink (may need sudo permissions)"
            fi
        fi
    fi

    state_complete "workspace"
    feature_enable "workspace_symlink"
    feature_persist "workspace_symlink" "true" 2>/dev/null || true
    pass "Workspace configured: $final_target"
}

phase_symlinks() {
    show_progress 2 7 "Symlinks"

    if state_completed "symlinks"; then
        pass "Symlinks already configured"
        return 0
    fi

    echo "This will link your shell configuration files."
    echo ""
    echo "Files to link:"
    echo "  ~/.zshrc     ‚Üí $DOTFILES_DIR/zsh/zshrc"
    echo "  ~/.p10k.zsh  ‚Üí $DOTFILES_DIR/zsh/p10k.zsh"
    echo ""

    echo -n "Create symlinks? [Y/n]: "
    read confirm
    if [[ "${confirm:-Y}" =~ ^[Nn]$ ]]; then
        warn "Skipped symlinks"
        return 1
    fi

    # Run symlink creation
    if [[ -f "$DOTFILES_DIR/bootstrap/bootstrap-dotfiles.sh" ]]; then
        "$DOTFILES_DIR/bootstrap/bootstrap-dotfiles.sh"
        state_complete "symlinks"
        pass "Symlinks created"
    else
        fail "bootstrap-dotfiles.sh not found"
        return 1
    fi
}

phase_packages() {
    show_progress 3 7 "Packages"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

    if state_completed "packages"; then
        pass "Packages already installed"
        return 0
    fi

    # Check if Homebrew is available
    if ! command -v brew &>/dev/null; then
        warn "Homebrew not installed - skipping package installation"
        echo "Install Homebrew and run 'dotfiles packages' later."
        return 0
    fi

    echo "This will install packages from Brewfile using Homebrew."

    # Count packages for each tier
    local minimal_count=0
    local enhanced_count=0
    local full_count=0

    if [[ -f "$DOTFILES_DIR/Brewfile.minimal" ]]; then
        minimal_count=$(grep -cE '^\s*(brew|cask|mas|tap)\s+' "$DOTFILES_DIR/Brewfile.minimal" 2>/dev/null || echo "18")
    fi
    if [[ -f "$DOTFILES_DIR/Brewfile.enhanced" ]]; then
        enhanced_count=$(grep -cE '^\s*(brew|cask|mas|tap)\s+' "$DOTFILES_DIR/Brewfile.enhanced" 2>/dev/null || echo "43")
    fi
    if [[ -f "$DOTFILES_DIR/Brewfile" ]]; then
        full_count=$(grep -cE '^\s*(brew|cask|mas|tap)\s+' "$DOTFILES_DIR/Brewfile" 2>/dev/null || echo "61")
    fi

    # Check if tier already selected
    local selected_tier=$(config_get "packages.tier" "")

    if [[ -z "$selected_tier" ]]; then
        # Interactive tier selection
        echo -e "${BOLD}Which package tier would you like?${NC}"
        echo ""
        echo -e "  ${GREEN}1)${NC} minimal    ${minimal_count} packages (~2 min)   ${DIM}# Essentials only${NC}"
        echo -e "  ${GREEN}2)${NC} enhanced   ${enhanced_count} packages (~5 min)   ${DIM}# Modern tools, no containers${NC} ${BOLD}‚Üê RECOMMENDED${NC}"
        echo -e "  ${GREEN}3)${NC} full       ${full_count} packages (~10 min)  ${DIM}# Everything (Docker, etc.)${NC}"
        echo ""
        echo -e "${DIM}Tip: You can always add more packages later with 'brew install <package>'${NC}"
        echo ""
        echo -n "Your choice [2]: "
        read tier_choice
        tier_choice=${tier_choice:-2}

        case "$tier_choice" in
            1)
                selected_tier="minimal"
                ;;
            2)
                selected_tier="enhanced"
                ;;
            3)
                selected_tier="full"
                ;;
            *)
                warn "Invalid choice, using enhanced tier"
                selected_tier="enhanced"
                ;;
        esac

        # Save preference
        config_set "packages.tier" "$selected_tier"
        info "Selected tier: $selected_tier"
        echo ""
    else
        pass "Using saved tier preference: $selected_tier"
        echo ""
    fi

    # Set package count based on tier
    local package_count
    local brewfile
    local time_estimate

    case "$selected_tier" in
        minimal)
            package_count=$minimal_count
            brewfile="$DOTFILES_DIR/Brewfile.minimal"
            time_estimate="~2 min"
            ;;
        enhanced)
            package_count=$enhanced_count
            brewfile="$DOTFILES_DIR/Brewfile.enhanced"
            time_estimate="~5 min"
            ;;
        full)
            package_count=$full_count
            brewfile="$DOTFILES_DIR/Brewfile"
            time_estimate="~10 min"
            ;;
        *)
            # Fallback to full
            package_count=$full_count
            brewfile="$DOTFILES_DIR/Brewfile"
            time_estimate="~10 min"
            ;;
    esac

    echo "This will install ${package_count} packages (${time_estimate})."
    echo -n "Install packages? [Y/n]: "
    read confirm
    if [[ "${confirm:-Y}" =~ ^[Nn]$ ]]; then
        warn "Skipped packages"
        return 0
    fi

    info "Running brew bundle with ${selected_tier} tier..."

    # Show progress by streaming output
    local brew_output
    local current_package=0
    (cd "$DOTFILES_DIR" && brew bundle --file="$brewfile" 2>&1) | while IFS= read -r line; do
        # Highlight package installations
        if [[ "$line" =~ "Installing " ]] || [[ "$line" =~ "Upgrading " ]]; then
            ((current_package++))
            echo -e "${CYAN}‚Üí${NC} $line ${DIM}($current_package/$package_count)${NC}"
        elif [[ "$line" =~ "Using " ]] || [[ "$line" =~ "Skipping " ]]; then
            echo -e "${DIM}  $line${NC}"
        elif [[ "$line" =~ "Error:" ]] || [[ "$line" =~ "Warning:" ]]; then
            echo -e "${YELLOW}  $line${NC}"
        fi
    done

    # Check exit status from brew bundle (not the while loop)
    # In zsh, pipestatus[1] gives the first command's exit code
    local brew_status=${pipestatus[1]}
    if [[ $brew_status -eq 0 ]]; then
        state_complete "packages"
        pass "Packages installed successfully (${selected_tier} tier)"
    else
        warn "Some packages may have failed - continuing"
        info "Run 'brew bundle --file=$brewfile' to retry failed packages"
        state_complete "packages"
    fi
}

phase_vault() {
    show_progress 4 7 "Vault Configuration"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

    if state_completed "vault"; then
        local backend=$(config_get "vault.backend" "")
        if [[ -n "$backend" ]] && [[ "$backend" != "none" ]]; then
            pass "Vault already configured ($backend)"
        elif [[ "$backend" == "none" ]]; then
            warn "Vault was skipped previously"
        else
            pass "Vault already configured"
        fi

        echo ""
        echo -n "Reconfigure vault? [y/N]: "
        read reconfigure
        if [[ "${reconfigure}" =~ ^[Yy]$ ]]; then
            info "Reconfiguring vault..."
            state_reset "vault"
            # Fall through to configuration below
        else
            if [[ "$backend" == "none" ]]; then
                info "Run 'dotfiles vault init' anytime to configure vault"
            fi
            return 0
        fi
    fi

    # Detect available vault backends
    local available=()
    if command -v bw &>/dev/null; then
        available+=("bitwarden")
    fi
    if command -v op &>/dev/null; then
        available+=("1password")
    fi
    if command -v pass &>/dev/null; then
        available+=("pass")
    fi

    if [[ ${#available[@]} -eq 0 ]]; then
        echo "No vault CLI detected. Vault features are optional."
        echo ""
        echo "Supported vault backends:"
        echo "  ‚Ä¢ Bitwarden:  brew install bitwarden-cli"
        echo "  ‚Ä¢ 1Password:  brew install 1password-cli"
        echo "  ‚Ä¢ pass:       brew install pass"
        echo ""
        echo -n "Skip vault setup? [Y/n]: "
        read skip
        if [[ "${skip:-Y}" =~ ^[Yy]$ ]]; then
            warn "Skipped vault setup"
            config_set "vault.backend" "none"
            state_complete "vault"
            echo ""
            info "Run 'dotfiles vault init' anytime to configure vault"
            return 0
        else
            echo "Please install a vault CLI and run 'dotfiles setup' again."
            return 1
        fi
    fi

    echo "Available vault backends:"
    for i in {1..${#available[@]}}; do
        echo "  $i) ${available[$i]}"
    done
    echo "  $((${#available[@]} + 1))) Skip (configure secrets manually)"

    echo -n "Select vault backend [1]: "
    read choice
    choice=${choice:-1}

    # Check if user chose to skip
    if [[ $choice -eq $((${#available[@]} + 1)) ]]; then
        warn "Skipped vault setup"
        config_set "vault.backend" "none"
        state_complete "vault"
        echo ""
        info "Run 'dotfiles vault init' anytime to configure vault"
        return 0
    fi

    local selected="${available[$choice]}"
    if [[ -z "$selected" ]]; then
        fail "Invalid selection"
        return 1
    fi

    # Save preference
    config_set "vault.backend" "$selected"
    export DOTFILES_VAULT_BACKEND="$selected"

    info "Using vault backend: $selected"

    # Check/create vault items configuration
    local vault_config="${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/vault-items.json"
    local vault_example="$DOTFILES_DIR/vault/vault-items.example.json"

    if [[ ! -f "$vault_config" ]]; then
        echo "Vault items configuration needed."
        echo ""
        echo "This config defines which secrets to manage:"
        echo "  ‚Ä¢ SSH keys (names and paths)"
        echo "  ‚Ä¢ Config files (AWS, Git, etc.)"
        echo ""

        # Create config directory
        mkdir -p "$(dirname "$vault_config")"

        # Copy example
        if [[ -f "$vault_example" ]]; then
            cp "$vault_example" "$vault_config"
            pass "Created $vault_config"
            echo ""
            echo "Please customize your vault items configuration."
            echo "Edit the file to match your vault item names and paths."
            echo ""
            echo -n "Open editor now? [Y/n]: "
            read edit_now
            if [[ "${edit_now:-Y}" =~ ^[Yy]$ ]]; then
                ${EDITOR:-vim} "$vault_config"
            fi
        else
            fail "Example config not found: $vault_example"
            return 1
        fi
    else
        pass "Vault items config exists"
    fi

    # Validate vault configuration schema
    echo ""
    info "Validating vault configuration schema..."
    if ! vault_validate_schema "$vault_config"; then
        echo ""
        fail "Vault configuration is invalid"
        echo ""
        echo -n "Open editor to fix now? [Y/n]: "
        read fix_now
        if [[ "${fix_now:-Y}" =~ ^[Yy]$ ]]; then
            ${EDITOR:-vim} "$vault_config"
            echo ""
            info "Re-validating after edit..."
            if ! vault_validate_schema "$vault_config"; then
                fail "Configuration is still invalid"
                echo ""
                echo "Please run 'dotfiles vault validate' to check errors"
                echo "Or run 'dotfiles setup' again when ready"
                return 1
            fi
        else
            warn "Skipping vault configuration - you can fix it later with 'dotfiles vault validate'"
            echo ""
            echo -n "Continue without vault? [y/N]: "
            read continue_anyway
            if [[ ! "${continue_anyway}" =~ ^[Yy]$ ]]; then
                return 1
            fi
        fi
    else
        pass "Vault configuration is valid"
    fi

    # Backend-specific login
    case "$selected" in
        bitwarden)
            if ! bw login --check &>/dev/null; then
                echo "Log in to Bitwarden:"
                bw login || { fail "Bitwarden login failed"; return 1; }
            fi

            if ! bw unlock --check &>/dev/null 2>&1; then
                echo ""
                info "Unlock your Bitwarden vault"
                echo "Enter your master password when prompted:"
                echo ""
                local session=""
                local attempts=0
                local max_attempts=5

                while [[ -z "$session" && $attempts -lt $max_attempts ]]; do
                    ((attempts++))
                    session=$(bw unlock --raw 2>/dev/null)

                    if [[ -z "$session" ]]; then
                        if [[ $attempts -lt $max_attempts ]]; then
                            echo ""
                            warn "Incorrect password. Attempt $attempts of $max_attempts."
                            echo "Try again:"
                        fi
                    fi
                done

                if [[ -n "$session" ]]; then
                    export BW_SESSION="$session"
                    # Cache session
                    echo "$session" > "$DOTFILES_DIR/vault/.vault-session"
                    chmod 600 "$DOTFILES_DIR/vault/.vault-session"
                    pass "Vault unlocked"
                else
                    fail "Failed to unlock vault after $max_attempts attempts"
                    echo "You can retry later with: dotfiles setup"
                    return 1
                fi
            else
                pass "Vault already unlocked"
            fi
            ;;

        1password)
            if ! op account list &>/dev/null 2>&1; then
                echo "Sign in to 1Password:"
                # Note: eval is required per 1Password CLI docs to set OP_SESSION
                eval "$(op signin)" || { fail "1Password signin failed"; return 1; }
            fi
            pass "1Password authenticated"
            ;;

        pass)
            # Note: 'pass' is both a command and our logging function
            # Use command pass to call the actual pass CLI
            if command pass ls &>/dev/null 2>&1; then
                pass "pass accessible (GPG agent active)"
            else
                warn "pass not accessible - check GPG configuration"
                echo "You may need to:"
                echo "  ‚Ä¢ Import your GPG key"
                echo "  ‚Ä¢ Initialize pass: pass init <gpg-key-id>"
                return 1
            fi
            ;;
    esac

    state_complete "vault"
    feature_enable "vault"
    feature_persist "vault" "true" 2>/dev/null || true
    pass "Vault configured"
}

phase_secrets() {
    show_progress 5 7 "Secrets Management"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

    if state_completed "secrets"; then
        pass "Secrets already configured"
        return 0
    fi

    local backend=$(config_get "vault.backend" "none")
    if [[ "$backend" == "none" ]]; then
        warn "Vault not configured - skipping secrets"
        echo "Configure secrets manually in ~/.ssh, ~/.aws, ~/.gitconfig"
        state_complete "secrets"
        return 0
    fi

    # Source vault common to get SYNCABLE_ITEMS
    source "$DOTFILES_DIR/vault/_common.sh"

    # Require vault config
    if ! require_vault_config; then
        fail "Cannot manage secrets without vault config"
        return 1
    fi

    # Detect local secrets and vault state
    local local_exists=()
    local vault_exists=()
    local local_only=()
    local vault_only=()
    local both_exist=()

    echo "Scanning secrets..."

    # Get vault session
    local session
    session=$(get_session 2>/dev/null) || true

    # Check each syncable item
    for item_name in "${(@k)SYNCABLE_ITEMS}"; do
        local local_path="${SYNCABLE_ITEMS[$item_name]}"
        local has_local=false
        local has_vault=false

        # Check local file
        if [[ -f "$local_path" ]]; then
            has_local=true
            local_exists+=("$item_name")
        fi

        # Check vault (if session available)
        if [[ -n "$session" ]] && vault_item_exists "$item_name" "$session" 2>/dev/null; then
            has_vault=true
            vault_exists+=("$item_name")
        fi

        # Categorize
        if $has_local && ! $has_vault; then
            local_only+=("$item_name")
        elif ! $has_local && $has_vault; then
            vault_only+=("$item_name")
        elif $has_local && $has_vault; then
            both_exist+=("$item_name")
        fi
    done

    # Also check SSH keys
    for item_name in "${(@k)SSH_KEYS}"; do
        local local_path="${SSH_KEYS[$item_name]}"
        local has_local=false
        local has_vault=false

        if [[ -f "$local_path" ]]; then
            has_local=true
        fi

        if [[ -n "$session" ]] && vault_item_exists "$item_name" "$session" 2>/dev/null; then
            has_vault=true
        fi

        if $has_local && ! $has_vault; then
            local_only+=("$item_name")
        elif ! $has_local && $has_vault; then
            vault_only+=("$item_name")
        elif $has_local && $has_vault; then
            both_exist+=("$item_name")
        fi
    done

    # Display status
    echo -e "${BOLD}Secrets Status:${NC}"

    if [[ ${#local_only[@]} -gt 0 ]]; then
        echo -e "  ${YELLOW}Local only (not in vault):${NC}"
        for item in "${local_only[@]}"; do
            local item_path="${SYNCABLE_ITEMS[$item]:-${SSH_KEYS[$item]:-}}"
            echo "    ‚Ä¢ $item ‚Üí $item_path"
        done
        echo ""
    fi

    if [[ ${#vault_only[@]} -gt 0 ]]; then
        echo -e "  ${CYAN}Vault only (can restore):${NC}"
        for item in "${vault_only[@]}"; do
            echo "    ‚Ä¢ $item"
        done
        echo ""
    fi

    if [[ ${#both_exist[@]} -gt 0 ]]; then
        echo -e "  ${GREEN}Synced (local + vault):${NC}"
        for item in "${both_exist[@]}"; do
            echo "    ‚Ä¢ $item"
        done
        echo ""
    fi

    # Offer to PUSH local secrets to vault
    if [[ ${#local_only[@]} -gt 0 ]]; then
        echo -e "${BOLD}${YELLOW}Found ${#local_only[@]} local secret(s) not in vault.${NC}"
        echo "Push these to $backend so you can restore on other machines."
        echo ""
        echo -n "Push local secrets to vault? [Y/n]: "
        read push_confirm
        if [[ "${push_confirm:-Y}" =~ ^[Yy]$ ]]; then
            echo ""
            local push_success=0
            local push_fail=0
            for item in "${local_only[@]}"; do
                echo -n "  Creating $item... "
                if "$DOTFILES_DIR/vault/create-vault-item.sh" "$item" 2>/dev/null; then
                    echo -e "${GREEN}done${NC}"
                    ((push_success++))
                else
                    echo -e "${RED}failed${NC}"
                    ((push_fail++))
                fi
            done
            echo ""
            if [[ $push_success -gt 0 ]]; then
                pass "Pushed $push_success secret(s) to vault"
            fi
            if [[ $push_fail -gt 0 ]]; then
                warn "$push_fail secret(s) failed to push"
            fi
        else
            info "Skipped pushing local secrets"
        fi
        echo ""
    fi

    # Offer to RESTORE from vault
    if [[ ${#vault_only[@]} -gt 0 ]]; then
        echo -e "${BOLD}${CYAN}Found ${#vault_only[@]} secret(s) in vault to restore.${NC}"
        echo ""
        echo -n "Restore secrets from vault? [Y/n]: "
        read restore_confirm
        if [[ "${restore_confirm:-Y}" =~ ^[Yy]$ ]]; then
            if "$DOTFILES_DIR/vault/restore.sh" --force; then
                pass "Secrets restored from vault"
            else
                warn "Some secrets may have failed to restore"
            fi
        else
            info "Skipped restoring from vault"
        fi
        echo ""
    fi

    # If nothing to do
    if [[ ${#local_only[@]} -eq 0 && ${#vault_only[@]} -eq 0 ]]; then
        if [[ ${#both_exist[@]} -gt 0 ]]; then
            pass "All secrets are already synced"
        else
            info "No secrets configured yet"
            echo "Add secrets to your local machine, then run 'dotfiles vault sync --all'"
        fi
    fi

    state_complete "secrets"
    pass "Secrets phase complete"
}

phase_claude() {
    show_progress 6 7 "Claude Code (Optional)"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

    if state_completed "claude"; then
        pass "Claude Code already configured"
        return 0
    fi

    # Check if Claude is installed
    if ! command -v claude &>/dev/null; then
        info "Claude Code not detected - skipping"
        state_complete "claude"
        return 0
    fi

    # Check if dotclaude is installed
    if command -v dotclaude &>/dev/null; then
        pass "dotclaude already installed"
        state_complete "claude"
        feature_enable "claude_integration"
        feature_enable "dotclaude"
        feature_persist "claude_integration" "true" 2>/dev/null || true
        feature_persist "dotclaude" "true" 2>/dev/null || true
        return 0
    fi

    echo "Claude Code detected. dotclaude helps manage profiles across machines."
    echo -n "Install dotclaude? [Y/n]: "
    read response

    if [[ "${response:-Y}" =~ ^[Yy]$ ]]; then
        info "Installing dotclaude..."
        if curl -fsSL https://raw.githubusercontent.com/blackwell-systems/dotclaude/main/install.sh | bash; then
            pass "dotclaude installed"
            state_complete "claude"
            feature_enable "claude_integration"
            feature_enable "dotclaude"
            feature_persist "claude_integration" "true" 2>/dev/null || true
            feature_persist "dotclaude" "true" 2>/dev/null || true
        else
            warn "dotclaude installation failed - continuing"
        fi
    else
        info "Skipped dotclaude installation"
        info "You can install later with: curl -fsSL https://dotclaude.sh | bash"
    fi
}

phase_template() {
    show_progress 7 7 "Machine-Specific Templates (Optional)"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

    if state_completed "template"; then
        pass "Templates already configured"
        return 0
    fi

    echo "Templates let you customize configs per machine (gitconfig, ssh-config, etc.)."
    echo "Examples:"
    echo "  ‚Ä¢ Work vs personal git email"
    echo "  ‚Ä¢ Different SSH keys per machine"
    echo "  ‚Ä¢ Machine-specific environment variables"
    echo -n "Setup machine-specific config templates? [y/N]: "
    read response

    if [[ "${response}" =~ ^[Yy]$ ]]; then
        info "Initializing template system..."
        echo ""

        # Run template init interactively
        if "$DOTFILES_DIR/bin/dotfiles-template" init; then
            pass "Templates configured"
            state_complete "template"
            feature_enable "templates"
            feature_persist "templates" "true" 2>/dev/null || true
            echo ""
            info "Run 'dotfiles template render' to generate configs from your templates"
        else
            warn "Template initialization skipped or failed"
        fi
    else
        info "Skipped template setup"
        echo ""
        info "You can enable templates later with: dotfiles template init"
    fi
}

# ============================================================
# Main Flow
# ============================================================

main() {
    # Initialize state
    state_init

    # Infer state for existing installations
    state_infer

    # Handle --status flag
    if $STATUS_ONLY; then
        show_status
        exit 0
    fi

    # Handle --reset flag
    if $FORCE_RESET; then
        echo -n "Reset all setup progress? [y/N]: "
        read confirm
        if [[ "${confirm:-N}" =~ ^[Yy]$ ]]; then
            for phase in workspace symlinks packages vault secrets claude template; do
                state_reset "$phase"
            done
            pass "State reset"
        else
            info "Reset cancelled"
            exit 0
        fi
    fi

    show_banner
    show_status

    # Check if setup is needed
    if ! state_needs_setup; then
        echo -e "${GREEN}${BOLD}All setup complete!${NC}"
        echo ""
        echo "Run 'dotfiles doctor' to verify health."
        echo "Run 'dotfiles setup --reset' to reconfigure."
        exit 0
    fi

    echo "Let's complete your setup..."
    echo ""
    show_steps_overview

    # Run each phase
    local phases=("workspace" "symlinks" "packages" "vault" "secrets" "claude" "template")
    local phase_funcs=("phase_workspace" "phase_symlinks" "phase_packages" "phase_vault" "phase_secrets" "phase_claude" "phase_template")

    for i in {1..${#phases[@]}}; do
        local phase="${phases[$i]}"
        local func="${phase_funcs[$i]}"

        if ! state_completed "$phase"; then
            $func || true  # Continue even if phase fails
        fi
    done

    # Final status
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    show_status

    if ! state_needs_setup; then
        echo ""
        echo -e "${GREEN}${BOLD}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
        echo -e "${GREEN}${BOLD}‚ïë              Setup Complete!                               ‚ïë${NC}"
        echo -e "${GREEN}${BOLD}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
        echo ""

        # Offer feature preset selection
        echo -e "${BOLD}Feature Presets${NC}"
        echo "Presets enable groups of shell features for different use cases."
        echo ""
        echo "  1) minimal    - Shell basics only (fastest startup)"
        echo "  2) developer  - + vault, git hooks, modern CLI tools"
        echo "  3) claude     - + Claude Code integration, workspace symlink"
        echo "  4) full       - All features enabled"
        echo "  5) Skip       - Configure features manually later"
        echo ""
        echo -n "Select a preset [3]: "
        read preset_choice
        preset_choice=${preset_choice:-3}

        local selected_preset=""
        case "$preset_choice" in
            1) selected_preset="minimal" ;;
            2) selected_preset="developer" ;;
            3) selected_preset="claude" ;;
            4) selected_preset="full" ;;
            5|*) selected_preset="" ;;
        esac

        if [[ -n "$selected_preset" ]]; then
            # Enable and persist the preset
            feature_preset_enable "$selected_preset"
            # Persist each feature in the preset
            local features="${FEATURE_PRESETS[$selected_preset]:-}"
            for feature in ${(s: :)features}; do
                feature_persist "$feature" "true" 2>/dev/null || true
            done
            pass "Applied '$selected_preset' preset"
        else
            info "Skipped preset selection"
            info "Configure later with: dotfiles features preset <name> --persist"
        fi
        echo ""

        # Show dynamic next steps based on configuration
        local vault_backend=$(config_get "vault.backend" "")
        local template_configured=false
        if [[ -f "$DOTFILES_DIR/templates/_variables.local.sh" ]]; then
            template_configured=true
        fi

        echo "Next steps based on your configuration:"
        echo ""

        # Vault-specific next steps
        if [[ -n "$vault_backend" ]] && [[ "$vault_backend" != "none" ]]; then
            echo -e "  ${CYAN}‚úì Vault configured${NC} ($vault_backend)"
            echo -e "    ${DIM}‚Üí${NC} ${BOLD}dotfiles vault validate${NC}    ${DIM}# Validate vault schema (recommended)${NC}"
            echo -e "    ${DIM}‚Üí${NC} ${BOLD}dotfiles vault restore${NC}     ${DIM}# Restore your secrets${NC}"
            echo ""
        fi

        # Template-specific next steps
        if $template_configured; then
            echo -e "  ${CYAN}‚úì Templates configured${NC}"
            echo -e "    ${DIM}‚Üí${NC} ${BOLD}dotfiles template render${NC}   ${DIM}# Generate configs${NC}"
            echo ""
        fi

        # Always show health check
        echo -e "  ${BLUE}‚Ñπ Health check:${NC}"
        echo -e "    ${DIM}‚Üí${NC} ${BOLD}dotfiles doctor${NC}             ${DIM}# Verify everything works${NC}"
        echo ""

        # Show helpful commands
        echo -e "  ${BLUE}‚Ñπ Explore commands:${NC}"
        echo -e "    ${DIM}‚Üí${NC} ${BOLD}dotfiles status${NC}             ${DIM}# Visual dashboard${NC}"
        echo -e "    ${DIM}‚Üí${NC} ${BOLD}dotfiles help${NC}               ${DIM}# See all commands${NC}"
        echo ""

        # ZSH features and aliases (show only what's available)
        local has_features=false
        local feature_lines=()

        # Check for modern CLI tools
        if command -v eza &>/dev/null; then
            feature_lines+=("    ${DIM}‚Üí${NC} ${BOLD}ll, la, lt${NC}                ${DIM}# Enhanced ls (eza with icons)${NC}")
            has_features=true
        fi

        # Git shortcuts are always available (defined in zsh config)
        if command -v git &>/dev/null; then
            feature_lines+=("    ${DIM}‚Üí${NC} ${BOLD}gst, gd, gco${NC}              ${DIM}# Git shortcuts${NC}")
            has_features=true
        fi

        if command -v fzf &>/dev/null; then
            feature_lines+=("    ${DIM}‚Üí${NC} ${BOLD}Ctrl+R${NC}                    ${DIM}# Fuzzy history search (fzf)${NC}")
            has_features=true
        fi

        if command -v zoxide &>/dev/null; then
            feature_lines+=("    ${DIM}‚Üí${NC} ${BOLD}z [directory]${NC}             ${DIM}# Smart cd (learns your habits)${NC}")
            has_features=true
        fi

        if command -v yazi &>/dev/null; then
            feature_lines+=("    ${DIM}‚Üí${NC} ${BOLD}y${NC}                         ${DIM}# Terminal file manager (yazi)${NC}")
            has_features=true
        fi

        # Only show section if we have features to display
        if $has_features; then
            echo -e "  ${BLUE}‚Ñπ Your new shell features:${NC}"
            printf '%b\n' "${feature_lines[@]}"
            echo ""
        fi

        # Documentation link
        echo -e "  ${DIM}üìö Docs: ${BLUE}https://github.com/blackwell-systems/dotfiles/docs${NC}"
    else
        echo -e "${YELLOW}Some steps were skipped or failed.${NC}"
        echo "Run 'dotfiles setup' again to continue."
    fi

}

# Run main
main "$@"
