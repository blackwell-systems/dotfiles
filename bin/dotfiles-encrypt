#!/usr/bin/env zsh
# ============================================================
# FILE: bin/dotfiles-encrypt
# Age encryption management for dotfiles
#
# Usage:
#   dotfiles encrypt init           # Initialize encryption (generate keys)
#   dotfiles encrypt <file>         # Encrypt a file
#   dotfiles encrypt decrypt <file> # Decrypt a file
#   dotfiles encrypt edit <file>    # Decrypt, edit, re-encrypt
#   dotfiles encrypt list           # List encrypted files
#   dotfiles encrypt status         # Show encryption status
#   dotfiles encrypt push-key       # Push key to vault for backup
#
# Examples:
#   dotfiles encrypt init
#   dotfiles encrypt templates/_variables.local.sh
#   dotfiles encrypt decrypt templates/_variables.local.sh.age
#   dotfiles encrypt edit templates/_variables.local.sh.age
# ============================================================

set -euo pipefail

# ============================================================
# Setup
# ============================================================
SCRIPT_DIR="${0:A:h}"
DOTFILES_DIR="${SCRIPT_DIR:h}"

# Source libraries
source "$DOTFILES_DIR/lib/_logging.sh"
source "$DOTFILES_DIR/lib/_features.sh"
source "$DOTFILES_DIR/lib/_encryption.sh"

# ============================================================
# Usage
# ============================================================
usage() {
    cat << 'EOF'
USAGE
    dotfiles encrypt <command> [options]

COMMANDS
    init              Initialize age encryption (generate key pair)
    encrypt <file>    Encrypt a file (creates <file>.age, removes original)
    decrypt <file>    Decrypt a .age file (removes .age, restores original)
    edit <file>       Decrypt, open in $EDITOR, re-encrypt on save
    list              List encrypted and unencrypted sensitive files
    status            Show encryption status and key info
    push-key          Push private key to vault for backup/recovery
    help              Show this help

OPTIONS
    --keep, -k        Keep original file when encrypting/decrypting
    --force, -f       Force operation (e.g., regenerate keys)
    --dry-run, -n     Show what would be done

EXAMPLES
    # First-time setup
    dotfiles encrypt init

    # Encrypt sensitive template variables
    dotfiles encrypt templates/_variables.local.sh

    # Decrypt to view/use
    dotfiles encrypt decrypt templates/_variables.local.sh.age

    # Edit encrypted file directly
    dotfiles encrypt edit templates/_variables.local.sh.age

    # Backup key to vault
    dotfiles encrypt push-key

INTEGRATION WITH HOOKS
    The encryption system integrates with dotfiles hooks:

    - pre_template_render: Auto-decrypts .age files before rendering
    - post_vault_pull: Restores age key from vault if missing locally

    This means:
    - 'dotfiles template render' automatically decrypts needed files
    - 'dotfiles vault pull' can restore your encryption key on new machines

SECURITY NOTES
    - Private key is stored in ~/.config/dotfiles/age-key.txt (mode 600)
    - Back up your private key to vault: dotfiles encrypt push-key
    - Without the private key, encrypted files cannot be recovered
    - The public key can be safely shared for others to encrypt files for you

EOF
}

# ============================================================
# Commands
# ============================================================

cmd_init() {
    local force=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true; shift ;;
            *) shift ;;
        esac
    done

    encryption_init "$force"
}

cmd_encrypt() {
    local file=""
    local keep=false
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --keep|-k) keep=true; shift ;;
            --dry-run|-n) dry_run=true; shift ;;
            -*) shift ;;
            *) file="$1"; shift ;;
        esac
    done

    if [[ -z "$file" ]]; then
        fail "No file specified"
        echo "Usage: dotfiles encrypt <file>"
        return 1
    fi

    if $dry_run; then
        echo "[DRY-RUN] Would encrypt: $file -> ${file}.age"
        return 0
    fi

    encrypt_file "$file" "${file}.age" "$keep"
}

cmd_decrypt() {
    local file=""
    local keep=false
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --keep|-k) keep=true; shift ;;
            --dry-run|-n) dry_run=true; shift ;;
            -*) shift ;;
            *) file="$1"; shift ;;
        esac
    done

    if [[ -z "$file" ]]; then
        fail "No file specified"
        echo "Usage: dotfiles encrypt decrypt <file.age>"
        return 1
    fi

    if $dry_run; then
        echo "[DRY-RUN] Would decrypt: $file -> ${file%.age}"
        return 0
    fi

    decrypt_file "$file" "${file%.age}" "$keep"
}

cmd_edit() {
    local file=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -*) shift ;;
            *) file="$1"; shift ;;
        esac
    done

    if [[ -z "$file" ]]; then
        fail "No file specified"
        echo "Usage: dotfiles encrypt edit <file>"
        return 1
    fi

    encrypt_edit "$file"
}

cmd_list() {
    encrypt_list
}

cmd_status() {
    encrypt_status
}

cmd_push_key() {
    encryption_push_key_to_vault
}

# ============================================================
# Main
# ============================================================
main() {
    # Check feature enabled
    if ! feature_enabled "encryption" 2>/dev/null; then
        # If feature doesn't exist yet, allow anyway for now
        :
    fi

    local command="${1:-help}"
    shift 2>/dev/null || true

    case "$command" in
        init)       cmd_init "$@" ;;
        encrypt)    cmd_encrypt "$@" ;;
        decrypt)    cmd_decrypt "$@" ;;
        edit)       cmd_edit "$@" ;;
        list)       cmd_list "$@" ;;
        status)     cmd_status "$@" ;;
        push-key)   cmd_push_key "$@" ;;
        help|--help|-h) usage ;;
        *)
            # Check if first arg is a file (shortcut for encrypt)
            if [[ -f "$command" ]]; then
                cmd_encrypt "$command" "$@"
            else
                fail "Unknown command: $command"
                echo ""
                usage
                return 1
            fi
            ;;
    esac
}

main "$@"
