#!/usr/bin/env zsh
# ============================================================
# FILE: bin/dotfiles-features
# Feature registry management command
# Usage: dotfiles features [command] [options]
# ============================================================
set -uo pipefail

# Determine script location
SCRIPT_DIR="$(cd "$(dirname "${0:a}")" && pwd)"
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"

# Source libraries
source "$DOTFILES_DIR/lib/_logging.sh"
source "$DOTFILES_DIR/lib/_config.sh"
source "$DOTFILES_DIR/lib/_features.sh"

# ============================================================
# Colors (for consistent output)
# ============================================================
GREEN="${GREEN:-\033[0;32m}"
RED="${RED:-\033[0;31m}"
YELLOW="${YELLOW:-\033[0;33m}"
CYAN="${CYAN:-\033[0;36m}"
BOLD="${BOLD:-\033[1m}"
DIM="${DIM:-\033[2m}"
NC="${NC:-\033[0m}"

# ============================================================
# Commands
# ============================================================

cmd_list() {
    local filter="${1:-}"
    local show_all=false
    local show_json=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all|-a) show_all=true; shift ;;
            --json|-j) show_json=true; shift ;;
            --category|-c) filter="$2"; shift 2 ;;
            core|optional|integration) filter="$1"; shift ;;
            *) shift ;;
        esac
    done

    if $show_json; then
        feature_status_all
        return 0
    fi

    echo -e "${BOLD}Feature Registry${NC}"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""

    local categories=("core" "optional" "integration")
    local category_labels=("Core (Always Enabled)" "Optional Features" "Integrations")
    local i cat label feature enabled desc deps status_icon status_color

    for i in {1..${#categories[@]}}; do
        cat="${categories[$i]}"
        label="${category_labels[$i]}"

        # Skip if filtering by category and this isn't it
        if [[ -n "$filter" && "$filter" != "$cat" ]]; then
            continue
        fi

        echo -e "${BOLD}${CYAN}$label${NC}"
        echo "───────────────────────────────────────────────────────────────"

        for feature in $(feature_list "$cat"); do
            enabled="false"
            feature_enabled "$feature" && enabled="true"

            desc="$(_feature_meta "$feature" "description")"
            deps="$(_feature_meta "$feature" "deps")"

            # Status indicator
            if [[ "$enabled" == "true" ]]; then
                status_icon="●"
                status_color="$GREEN"
            else
                status_icon="○"
                status_color="$DIM"
            fi

            # Format output
            printf "  ${status_color}%s${NC} %-20s ${DIM}%s${NC}\n" "$status_icon" "$feature" "$desc"

            # Show dependencies if any and --all flag
            if $show_all && [[ -n "$deps" ]]; then
                printf "    ${DIM}└─ requires: %s${NC}\n" "$deps"
            fi
        done
        echo ""
    done

    echo -e "${DIM}Legend: ${GREEN}●${NC} enabled  ${DIM}○ disabled${NC}"
    echo -e "${DIM}Use 'dotfiles features enable <name>' to enable a feature${NC}"
}

cmd_status() {
    local feature="$1"

    if [[ -z "$feature" ]]; then
        # Show all features status
        cmd_list --all
        return 0
    fi

    if ! feature_exists "$feature"; then
        fail "Unknown feature: $feature"
        echo ""
        echo "Available features:"
        feature_list | sed 's/^/  /'
        return 1
    fi

    feature_status "$feature"
}

cmd_enable() {
    local feature="$1"
    local persist=false

    # Parse flags
    shift 2>/dev/null || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --persist|-p) persist=true; shift ;;
            *) shift ;;
        esac
    done

    if [[ -z "$feature" ]]; then
        fail "Usage: dotfiles features enable <feature> [--persist]"
        return 1
    fi

    if ! feature_exists "$feature"; then
        fail "Unknown feature: $feature"
        echo ""
        echo "Available features:"
        feature_list | sed 's/^/  /'
        return 1
    fi

    # Check if it's a core feature
    local category
    category="$(_feature_meta "$feature" "category")"
    if [[ "$category" == "core" ]]; then
        info "Feature '$feature' is a core feature (always enabled)"
        return 0
    fi

    # Collect all dependencies recursively (for persist)
    local deps_to_enable=()
    _collect_deps_recursive() {
        local feat="$1"
        local deps
        deps="$(_feature_meta "$feat" "deps")"
        if [[ -n "$deps" ]]; then
            for dep in ${(s: :)deps}; do
                if ! feature_enabled "$dep"; then
                    # Recurse first (to get deps of deps)
                    _collect_deps_recursive "$dep"
                    # Then add this dep if not already in list
                    if [[ ! " ${deps_to_enable[*]} " =~ " ${dep} " ]]; then
                        deps_to_enable+=("$dep")
                    fi
                fi
            done
        fi
    }
    _collect_deps_recursive "$feature"

    if [[ ${#deps_to_enable[@]} -gt 0 ]]; then
        info "Enabling dependencies first: ${deps_to_enable[*]}"
    fi

    # Enable the feature (and dependencies via feature_enable)
    feature_enable "$feature"

    if $persist; then
        # Persist dependencies first (in order)
        for dep in "${deps_to_enable[@]}"; do
            feature_persist "$dep" "true" 2>/dev/null || true
        done
        # Persist the main feature
        feature_persist "$feature" "true"
        pass "Feature '$feature' enabled and saved to config"
    else
        pass "Feature '$feature' enabled (runtime only)"
        echo -e "${DIM}Use --persist to save to config file${NC}"
    fi
}

cmd_disable() {
    local feature="$1"
    local persist=false

    # Parse flags
    shift 2>/dev/null || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --persist|-p) persist=true; shift ;;
            *) shift ;;
        esac
    done

    if [[ -z "$feature" ]]; then
        fail "Usage: dotfiles features disable <feature> [--persist]"
        return 1
    fi

    if ! feature_exists "$feature"; then
        fail "Unknown feature: $feature"
        return 1
    fi

    # Check if it's a core feature
    local category
    category="$(_feature_meta "$feature" "category")"
    if [[ "$category" == "core" ]]; then
        fail "Cannot disable core feature: $feature"
        return 1
    fi

    # Disable the feature
    feature_disable "$feature"

    if $persist; then
        feature_persist "$feature" "false"
        pass "Feature '$feature' disabled and saved to config"
    else
        pass "Feature '$feature' disabled (runtime only)"
        echo -e "${DIM}Use --persist to save to config file${NC}"
    fi
}

cmd_preset() {
    local preset=""
    local persist=false

    # Parse all arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --persist|-p) persist=true; shift ;;
            --list|-l)
                echo -e "${BOLD}Available Presets${NC}"
                echo "─────────────────────────────────────────────────"
                feature_preset_list | while read -r line; do
                    local name="${line%%:*}"
                    local features="${line#*: }"
                    echo -e "  ${CYAN}$name${NC}"
                    echo -e "    ${DIM}$features${NC}"
                done
                return 0
                ;;
            -*)
                # Skip unknown flags
                shift
                ;;
            *)
                # First non-flag argument is the preset name
                if [[ -z "$preset" ]]; then
                    preset="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$preset" ]]; then
        fail "Usage: dotfiles features preset <name> [--persist]"
        echo ""
        echo "Available presets:"
        feature_preset_list | cut -d: -f1 | sed 's/^/  /'
        return 1
    fi

    # Enable the preset
    if ! feature_preset_enable "$preset" 2>/dev/null; then
        fail "Unknown preset: $preset"
        echo ""
        echo "Available presets:"
        feature_preset_list | cut -d: -f1 | sed 's/^/  /'
        return 1
    fi

    if $persist; then
        # Persist all features in the preset
        local features="${FEATURE_PRESETS[$preset]:-}"
        for feature in ${(s: :)features}; do
            feature_persist "$feature" "true" 2>/dev/null || true
        done
        pass "Preset '$preset' enabled and saved to config"
    else
        pass "Preset '$preset' enabled (runtime only)"
        echo -e "${DIM}Use --persist to save to config file${NC}"
    fi

    echo ""
    echo "Enabled features:"
    local features="${FEATURE_PRESETS[$preset]:-}"
    for feature in ${(s: :)features}; do
        echo -e "  ${GREEN}●${NC} $feature"
    done
}

cmd_check() {
    local feature="$1"

    if [[ -z "$feature" ]]; then
        fail "Usage: dotfiles features check <feature>"
        return 1
    fi

    if ! feature_exists "$feature"; then
        fail "Unknown feature: $feature"
        return 1
    fi

    if feature_enabled "$feature"; then
        pass "Feature '$feature' is enabled"
        return 0
    else
        info "Feature '$feature' is disabled"
        return 1
    fi
}

cmd_help() {
    cat << 'EOF'
dotfiles features - Feature registry management

Usage: dotfiles features <command> [options]

Commands:
  list [category]     List all features and their status
                      Categories: core, optional, integration
                      --all: Show dependencies
                      --json: Output as JSON

  status [feature]    Show feature status (all or specific)

  enable <feature>    Enable a feature
                      --persist: Save to config file

  disable <feature>   Disable a feature
                      --persist: Save to config file

  preset <name>       Enable a preset (group of features)
                      --list: Show available presets
                      --persist: Save to config file

  check <feature>     Check if a feature is enabled (for scripts)
                      Returns exit code 0 if enabled, 1 if disabled

  help                Show this help

Available Presets:
  minimal     Shell only (fastest startup)
  developer   vault, aws_helpers, git_hooks, modern_cli
  claude      workspace_symlink, claude_integration, vault, git_hooks
  full        All features enabled

Examples:
  dotfiles features                      # List all features
  dotfiles features list optional        # List optional features only
  dotfiles features enable vault         # Enable vault (runtime)
  dotfiles features enable vault -p      # Enable and persist
  dotfiles features preset developer     # Enable developer preset
  dotfiles features check vault && ...   # Conditional execution

Environment Variables:
  Features can also be controlled via environment variables:
    SKIP_WORKSPACE_SYMLINK=true    Disable workspace_symlink
    SKIP_CLAUDE_SETUP=true         Disable claude_integration
    DOTFILES_SKIP_DRIFT_CHECK=1    Disable drift_check
    DOTFILES_FEATURE_<NAME>=true   Enable/disable any feature

EOF
}

# ============================================================
# Main
# ============================================================

main() {
    local cmd="${1:-list}"
    shift 2>/dev/null || true

    case "$cmd" in
        list|ls)        cmd_list "$@" ;;
        status|show)    cmd_status "$@" ;;
        enable|on)      cmd_enable "$@" ;;
        disable|off)    cmd_disable "$@" ;;
        preset)         cmd_preset "$@" ;;
        check|test)     cmd_check "$@" ;;
        help|--help|-h) cmd_help ;;
        *)
            fail "Unknown command: $cmd"
            echo "Run 'dotfiles features help' for usage"
            return 1
            ;;
    esac
}

main "$@"
