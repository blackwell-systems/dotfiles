# =========================
# Powerlevel10k instant prompt (must stay near top)
# =========================
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Detect OS
OS="$(uname -s)"

# =========================
# OS-SPECIFIC SETUP
# =========================
case "$OS" in
  Darwin)
    # ---------- macOS ----------
    # Homebrew shell environment (Apple Silicon or Intel)
    if [ -x /opt/homebrew/bin/brew ]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [ -x /usr/local/bin/brew ]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi

    # Lima VM management (if lima is installed)
    if command -v limactl >/dev/null 2>&1; then
      alias lima-dev='limactl shell dev-ubuntu'
      alias lima-start='limactl start dev-ubuntu'
      alias lima-stop='limactl stop dev-ubuntu'
      alias lima-status='limactl list'
    fi
    ;;

  Linux)
    # ---------- Linux (Lima dev-ubuntu) ----------
    # Fix TERM so apps like nano don't choke on xterm-ghostty
    export TERM=xterm-256color

    # Lima recommendation: make sure system tools are in PATH
    PATH="$PATH:/usr/sbin:/sbin"
    export PATH

    # Homebrew (linuxbrew) bootstrap
    if [ -x /home/linuxbrew/.linuxbrew/bin/brew ]; then
      eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
    fi

    # Enable ls colors on Linux
    if command -v dircolors >/dev/null 2>&1; then
      eval "$(dircolors -b)"
    fi
    alias ls='ls --color=auto'
    alias ll='ls -lash --color=auto'
    alias la='ls -Ah --color=auto'
    alias l='ls -CF --color=auto'

    # Snap (if present on Linux)
    if [ -d /snap/bin ]; then
      export PATH="/snap/bin:$PATH"
    fi
    ;;
esac

# =========================
# SHARED PLUGIN LOADING (brew-managed)
# =========================
# Unified approach: both macOS and Linux use brew-installed plugins directly.
# No Oh-My-Zsh dependency - faster startup, simpler config.

if command -v brew >/dev/null 2>&1; then
  BREW_PREFIX="$(brew --prefix)"

  # zsh-autosuggestions
  if [ -f "$BREW_PREFIX/share/zsh-autosuggestions/zsh-autosuggestions.zsh" ]; then
    source "$BREW_PREFIX/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
  fi

  # Powerlevel10k theme
  if [ -f "$BREW_PREFIX/share/powerlevel10k/powerlevel10k.zsh-theme" ]; then
    source "$BREW_PREFIX/share/powerlevel10k/powerlevel10k.zsh-theme"
  fi
fi

# =========================
# SHARED PROMPT CONFIG
# =========================
# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ -f "$HOME/.p10k.zsh" ]] && source "$HOME/.p10k.zsh"

# =========================
# MODERN CLI TOOLS (eza, fzf, etc.)
# =========================
# These override basic coreutils with modern alternatives when available.

# eza - modern ls replacement (cross-platform)
if command -v eza >/dev/null 2>&1; then
  alias ls='eza --color=auto --group-directories-first'
  alias ll='eza -la --icons --group-directories-first --git'
  alias la='eza -a --icons --group-directories-first'
  alias lt='eza -la --icons --tree --level=2'
  alias l='eza -1'
  alias lm='eza -la --icons --sort=modified'
  alias lr='eza -la --icons --sort=size --reverse'
fi

# fzf - fuzzy finder
if command -v fzf >/dev/null 2>&1; then
  # Use fd for fzf if available (faster, respects .gitignore)
  if command -v fd >/dev/null 2>&1; then
    export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git'
    export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    export FZF_ALT_C_COMMAND='fd --type d --hidden --follow --exclude .git'
  fi

  # fzf appearance
  export FZF_DEFAULT_OPTS='--height 40% --layout=reverse --border --info=inline'

  # Load fzf keybindings and completions
  if [[ -f "$BREW_PREFIX/opt/fzf/shell/key-bindings.zsh" ]]; then
    source "$BREW_PREFIX/opt/fzf/shell/key-bindings.zsh"
  fi
  if [[ -f "$BREW_PREFIX/opt/fzf/shell/completion.zsh" ]]; then
    source "$BREW_PREFIX/opt/fzf/shell/completion.zsh"
  fi
fi

# dust - intuitive disk usage (du replacement)
if command -v dust >/dev/null 2>&1; then
  alias du='dust'
  alias dus='dust -s'      # summary only
  alias dud='dust -d 1'    # depth 1
fi

# yazi - terminal file manager (cd to directory on exit)
if command -v yazi >/dev/null 2>&1; then
  # y: launch yazi and cd to directory when you quit
  y() {
    local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
    yazi "$@" --cwd-file="$tmp"
    if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
      cd -- "$cwd"
    fi
    rm -f -- "$tmp"
  }
  alias fm='y'  # muscle memory alias
fi

# yq - YAML processor (like jq for YAML)
# Usage: yq '.spec.containers[0].image' deployment.yaml
#        cat config.yaml | yq '.database.host'
#        yq -i '.version = "2.0"' config.yaml  # in-place edit

# =========================
# SHARED ENV / TOOLING
# =========================

# Shared workspace (macOS + Lima both use ~/workspace now)
export WORKSPACE="$HOME/workspace"

# =========================
# SHARED HISTORY (cross-platform)
# =========================
# Store history in workspace so it syncs across macOS and Lima
HISTFILE="$HOME/workspace/.zsh_history"
HISTSIZE=50000
SAVEHIST=50000
setopt SHARE_HISTORY          # Share history between sessions
setopt HIST_IGNORE_DUPS       # Don't record duplicates
setopt HIST_IGNORE_SPACE      # Don't record commands starting with space
setopt HIST_REDUCE_BLANKS     # Remove extra blanks
setopt INC_APPEND_HISTORY     # Add commands immediately (not at shell exit)

# Convenience navigation aliases
alias cws='cd "$WORKSPACE"'
alias ccode='cd "$WORKSPACE/code"'
alias cwhite='cd "$WORKSPACE/whitepapers"'
alias cpat='cd "$WORKSPACE/patent-pool"'

# Bitwarden vault helpers
alias bw-restore='$HOME/workspace/dotfiles/vault/bootstrap-vault.sh'
alias bw-sync='$HOME/workspace/dotfiles/vault/sync-to-bitwarden.sh'
alias bw-create='$HOME/workspace/dotfiles/vault/create-vault-item.sh'
alias bw-delete='$HOME/workspace/dotfiles/vault/delete-vault-item.sh'
alias bw-list='$HOME/workspace/dotfiles/vault/list-vault-items.sh'
alias bw-check='$HOME/workspace/dotfiles/vault/check-vault-items.sh'

# Dotfiles management helpers
alias dotfiles='cd $HOME/workspace/dotfiles'
alias dotfiles-doctor='$HOME/workspace/dotfiles/check-health.sh && bw-check 2>/dev/null'

# Quick status dashboard - city skyline theme
status() {
  local fixes=()

  # Gather detailed status
  local s_zshrc="◇" s_zshrc_info="not linked"
  if [[ -L ~/.zshrc ]]; then
    s_zshrc="◆"; s_zshrc_info="→ dotfiles/zsh/zshrc"
  else
    fixes+=("zshrc: bootstrap-dotfiles.sh")
  fi

  local s_claude="◇" s_claude_info="not linked"
  if [[ -L ~/.claude ]]; then
    s_claude="◆"; s_claude_info="→ workspace/.claude"
  else
    fixes+=("claude: bootstrap-dotfiles.sh")
  fi

  local s_workspace="◇" s_workspace_info="missing"
  if [[ -L /workspace ]]; then
    s_workspace="◆"; s_workspace_info="→ $(readlink /workspace)"
  else
    fixes+=("/workspace: sudo ln -sfn \$HOME/workspace /workspace")
  fi

  local ssh_count=$(ssh-add -l 2>/dev/null | wc -l | tr -d ' ')
  local s_ssh="◇" s_ssh_info="no keys"
  if [[ "$ssh_count" -gt 0 ]]; then
    s_ssh="◆"; s_ssh_info="$ssh_count keys loaded"
  else
    fixes+=("ssh: bw-restore")
  fi

  local s_aws="◇" s_aws_info="not authenticated"
  if aws sts get-caller-identity --profile "${_CLAUDE_BEDROCK_PROFILE:-dev-profile}" &>/dev/null; then
    s_aws="◆"; s_aws_info="authenticated"
  else
    fixes+=("aws: awslogin")
  fi

  local s_lima="·" s_lima_info=""
  if [[ "$OS" == "Darwin" ]] && command -v limactl &>/dev/null; then
    if limactl list 2>/dev/null | grep -q Running; then
      s_lima="◆"; s_lima_info="running"
    else
      s_lima="◇"; s_lima_info="stopped"
      fixes+=("lima: lima-start")
    fi
  fi

  # City skyline with status windows
  cat << EOF

                ▄▄▄▄▄
               ▐█$s_aws█▌
       ▄▄▄▄▄   ▐█ █▌  ▄▄▄▄▄▄▄
      ▐█$s_zshrc█▌  ▐███▌ ▐██$s_lima██▌
      ▐█ █▌  ▐███▌ ▐██ ██▌
  ▄▄▄▄████▄▄▄▄████▄▄████████▄▄▄▄
 ▐██$s_claude██$s_ssh██████$s_workspace██████████████▌
 ▐██ ██ ██████ ██████████████▌
▄██████████████████████████████▄
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

EOF

  # Diagnostic details
  echo "  zshrc     $s_zshrc  $s_zshrc_info"
  echo "  claude    $s_claude  $s_claude_info"
  echo "  /workspace$s_workspace  $s_workspace_info"
  echo "  ssh       $s_ssh  $s_ssh_info"
  echo "  aws       $s_aws  $s_aws_info"
  [[ -n "$s_lima_info" ]] && echo "  lima      $s_lima  $s_lima_info"
  echo ""

  # Fixes if needed
  if [[ ${#fixes[@]} -gt 0 ]]; then
    echo "  ┌─ fixes ────────────────────────────────"
    for fix in "${fixes[@]}"; do
      echo "  │ $fix"
    done
    echo "  └─────────────────────────────────────────"
    echo ""
  fi
}

# =========================
# PROJECT NAVIGATION (fzf-powered)
# =========================
# Jump to any project by fuzzy search on git repos in /workspace
j() {
  if ! command -v fzf >/dev/null 2>&1; then
    echo "fzf not installed. Install with: brew install fzf" >&2
    return 1
  fi

  local base_dir="${1:-/workspace}"
  local dir

  if command -v fd >/dev/null 2>&1; then
    # fd is faster and respects .gitignore
    dir=$(fd -H -t d '^\.git$' "$base_dir" --max-depth 4 2>/dev/null |
      xargs -I{} dirname {} |
      fzf --preview 'ls -la {} 2>/dev/null | head -20' \
          --preview-window=right:40% \
          --header="Jump to project (ESC to cancel)")
  else
    # Fallback to find
    dir=$(find "$base_dir" -maxdepth 4 -type d -name ".git" 2>/dev/null |
      xargs -I{} dirname {} |
      fzf --preview 'ls -la {} 2>/dev/null | head -20' \
          --preview-window=right:40% \
          --header="Jump to project (ESC to cancel)")
  fi

  [[ -n "$dir" ]] && cd "$dir"
}

# =========================
# QUICK NOTES (timestamped markdown)
# =========================
# Capture thoughts, commands, ideas instantly
note() {
  local notes_file="$HOME/workspace/.notes.md"

  # Create file with header if it doesn't exist
  if [[ ! -f "$notes_file" ]]; then
    echo "# Quick Notes" > "$notes_file"
    echo "" >> "$notes_file"
  fi

  if [[ $# -eq 0 ]]; then
    echo "Usage: note <your note text>" >&2
    echo "       notes           # view recent notes" >&2
    echo "       notes all       # view all notes" >&2
    echo "       notes edit      # open notes file" >&2
    return 1
  fi

  echo "- **$(date +%Y-%m-%d\ %H:%M)** | $*" >> "$notes_file"
  echo "✓ Note saved"
}

# View notes
notes() {
  local notes_file="$HOME/workspace/.notes.md"

  if [[ ! -f "$notes_file" ]]; then
    echo "No notes yet. Create one with: note <your note>" >&2
    return 1
  fi

  case "${1:-}" in
    all)
      cat "$notes_file"
      ;;
    edit)
      ${EDITOR:-nano} "$notes_file"
      ;;
    search)
      shift
      grep -i "$*" "$notes_file"
      ;;
    *)
      echo "═══ Recent Notes (last 20) ═══"
      tail -20 "$notes_file"
      echo ""
      echo "Tip: notes all | notes edit | notes search <term>"
      ;;
  esac
}

dotfiles-update() {
    local DOTFILES_DIR="$HOME/workspace/dotfiles"
    local branch
    branch="$(cd "$DOTFILES_DIR" && git rev-parse --abbrev-ref HEAD)"
    echo "Updating dotfiles (branch: $branch)..."
    (cd "$DOTFILES_DIR" && git pull --rebase origin "$branch")
    echo "Re-sourcing zshrc..."
    source "$HOME/.zshrc"
    echo "Done! Run 'dotfiles-doctor' to verify."
}

# Load your custom env block if it exists
if [ -f "$HOME/.local/bin/env" ]; then
  . "$HOME/.local/bin/env"
fi

# =========================
# SSH Agent (lazy start + auto-add keys)
# =========================
# Auto-start ssh-agent if not running (common on Lima/Linux)
# macOS uses Keychain, so SSH_AUTH_SOCK is usually set by launchd
if [[ -z "$SSH_AUTH_SOCK" ]]; then
  eval "$(ssh-agent -s)" > /dev/null
fi

# Add keys if not already added (silent, only if key exists)
_ssh_add_if_missing() {
  local key="$1"
  [[ ! -f "$key" ]] && return 0

  # Get fingerprint of the key file
  local fp
  fp="$(ssh-keygen -lf "$key" 2>/dev/null | awk '{print $2}')" || return 0

  # Check if already loaded
  if ! ssh-add -l 2>/dev/null | grep -qF "$fp"; then
    ssh-add -q "$key" 2>/dev/null
  fi
}

# SSH keys to auto-add (canonical list in vault/_common.sh SSH_KEYS array)
_ssh_add_if_missing ~/.ssh/id_ed25519_enterprise_ghub
_ssh_add_if_missing ~/.ssh/id_ed25519_blackwell

# SDKMAN
export SDKMAN_DIR="$HOME/.sdkman"
[[ -s "$HOME/.sdkman/bin/sdkman-init.sh" ]] && source "$HOME/.sdkman/bin/sdkman-init.sh"

# Best Western config
export ENV=prod
export BWH_CONFIG_DIR="$HOME/.config/bwh"

# Node / nvm setup (safe on both OSes)
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
[ -s "$NVM_DIR/bash_completion" ] && . "$NVM_DIR/bash_completion"

# =========================
# AWS Profile Management
# =========================

# List all configured AWS profiles
awsprofiles() {
  echo "Available AWS profiles:"
  aws configure list-profiles 2>/dev/null | while read -r profile; do
    if [[ "$profile" == "${AWS_PROFILE:-}" ]]; then
      echo "  * $profile (active)"
    else
      echo "    $profile"
    fi
  done
}

# Interactive profile selector (requires fzf)
awsswitch() {
  if ! command -v fzf >/dev/null 2>&1; then
    echo "fzf not installed. Use: awsset <profile>" >&2
    return 1
  fi

  local profile
  profile=$(aws configure list-profiles 2>/dev/null | fzf --header="Select AWS profile")

  if [[ -n "$profile" ]]; then
    export AWS_PROFILE="$profile"
    echo "Switched to AWS_PROFILE=$profile"

    # Check if SSO login is needed
    if ! aws sts get-caller-identity &>/dev/null; then
      echo "Session expired. Logging in..."
      aws sso login --profile "$profile"
    fi
    awswho
  fi
}

# Set AWS profile for current shell
awsset() {
  if [[ -z "$1" ]]; then
    echo "Usage: awsset <profile>" >&2
    echo "Available profiles: $(aws configure list-profiles 2>/dev/null | tr '\n' ' ')" >&2
    return 1
  fi
  export AWS_PROFILE="$1"
  echo "Set AWS_PROFILE=$1"
}

# Unset AWS profile (return to default)
awsunset() {
  unset AWS_PROFILE
  echo "Cleared AWS_PROFILE (using default)"
}

# Show current AWS identity
awswho() {
  local profile="${AWS_PROFILE:-default}"
  echo "Profile: $profile"
  aws sts get-caller-identity --output table 2>/dev/null || echo "Not authenticated. Run: awslogin $profile"
}

# SSO login helper
awslogin() {
  local p="${1:-${AWS_PROFILE:-dev-profile}}"
  echo "Logging in to AWS SSO profile: $p"
  aws sso login --profile "$p"
  # Optionally set as active profile
  if [[ -z "$AWS_PROFILE" ]]; then
    export AWS_PROFILE="$p"
    echo "Set AWS_PROFILE=$p"
  fi
}

# Quick assume role (for cross-account access)
awsassume() {
  local role_arn="$1"
  local session_name="${2:-cli-session}"

  if [[ -z "$role_arn" ]]; then
    echo "Usage: awsassume <role-arn> [session-name]" >&2
    return 1
  fi

  local creds
  creds=$(aws sts assume-role --role-arn "$role_arn" --role-session-name "$session_name" --output json)

  if [[ $? -eq 0 ]]; then
    export AWS_ACCESS_KEY_ID=$(echo "$creds" | jq -r '.Credentials.AccessKeyId')
    export AWS_SECRET_ACCESS_KEY=$(echo "$creds" | jq -r '.Credentials.SecretAccessKey')
    export AWS_SESSION_TOKEN=$(echo "$creds" | jq -r '.Credentials.SessionToken')
    echo "Assumed role: $role_arn"
    awswho
  else
    echo "Failed to assume role" >&2
    return 1
  fi
}

# Clear assumed role credentials
awsclear() {
  unset AWS_ACCESS_KEY_ID
  unset AWS_SECRET_ACCESS_KEY
  unset AWS_SESSION_TOKEN
  echo "Cleared temporary credentials"
}

# Show all AWS commands with banner
awstools() {
  cat << 'EOF'

   █████╗ ██╗    ██╗███████╗    ████████╗ ██████╗  ██████╗ ██╗     ███████╗
  ██╔══██╗██║    ██║██╔════╝    ╚══██╔══╝██╔═══██╗██╔═══██╗██║     ██╔════╝
  ███████║██║ █╗ ██║███████╗       ██║   ██║   ██║██║   ██║██║     ███████╗
  ██╔══██║██║███╗██║╚════██║       ██║   ██║   ██║██║   ██║██║     ╚════██║
  ██║  ██║╚███╔███╔╝███████║       ██║   ╚██████╔╝╚██████╔╝███████╗███████║
  ╚═╝  ╚═╝ ╚══╝╚══╝ ╚══════╝       ╚═╝    ╚═════╝  ╚═════╝ ╚══════╝╚══════╝

EOF

  echo "  ╭─────────────────────────────────────────────────────────────────╮"
  echo "  │                    PROFILE MANAGEMENT                          │"
  echo "  ├─────────────────────────────────────────────────────────────────┤"
  echo "  │  awsprofiles        List all profiles (* = active)             │"
  echo "  │  awsswitch          Fuzzy-select profile (fzf) + auto-login    │"
  echo "  │  awsset <profile>   Set AWS_PROFILE for this shell             │"
  echo "  │  awsunset           Clear AWS_PROFILE                          │"
  echo "  ├─────────────────────────────────────────────────────────────────┤"
  echo "  │                    AUTHENTICATION                              │"
  echo "  ├─────────────────────────────────────────────────────────────────┤"
  echo "  │  awslogin [profile] SSO login (defaults to current profile)    │"
  echo "  │  awswho             Show current identity (account/user/ARN)   │"
  echo "  ├─────────────────────────────────────────────────────────────────┤"
  echo "  │                    ROLE ASSUMPTION                             │"
  echo "  ├─────────────────────────────────────────────────────────────────┤"
  echo "  │  awsassume <arn>    Assume role for cross-account access       │"
  echo "  │  awsclear           Clear temporary assumed-role credentials   │"
  echo "  ╰─────────────────────────────────────────────────────────────────╯"
  echo ""
  echo "  Current status:"
  local profile="${AWS_PROFILE:-<not set>}"
  echo "    AWS_PROFILE = $profile"
  if aws sts get-caller-identity &>/dev/null; then
    echo "    Session     = ✓ authenticated"
  else
    echo "    Session     = ✗ not authenticated (run awslogin)"
  fi
  echo ""
}

# =========================
# Claude workspace wrapper
# =========================
# Automatically use /workspace path for portable session history.
# When in ~/workspace/*, transparently cd to /workspace/* before running claude.
claude() {
  if [[ "$PWD" == "$HOME/workspace"* && -d "/workspace" ]]; then
    local canonical_path="/workspace${PWD#$HOME/workspace}"
    if [[ -d "$canonical_path" ]]; then
      ( cd "$canonical_path" && command claude "$@" )
      return $?
    fi
  fi
  command claude "$@"
}

# =========================
# Claude routing helpers (shared)
# =========================

# Centralize Bedrock config here so you only edit in one place.
_CLAUDE_BEDROCK_PROFILE="dev-profile"            # SSO profile name
_CLAUDE_BEDROCK_REGION="us-west-2"               # Bedrock region
_CLAUDE_BEDROCK_MODEL="us.anthropic.claude-sonnet-4-5-20250929-v1:0"

# Optional fast model (leave as-is if you don't have this inference profile)
_CLAUDE_BEDROCK_FAST_MODEL="us.anthropic.claude-3-5-haiku-20241022-v1:0"

CLAUDE_CODE_MAX_OUTPUT_TOKENS=60000

# Helper: ensure AWS SSO session is valid
_ensure_aws_sso() {
    if ! aws sts get-caller-identity --profile "$_CLAUDE_BEDROCK_PROFILE" >/dev/null 2>&1; then
        echo "AWS SSO session expired. Logging in..." >&2
        aws sso login --profile "$_CLAUDE_BEDROCK_PROFILE" || return 1
    fi
}

# --- claude-bedrock ---
claude-bedrock() {
    # Pre-flight: ensure SSO session is valid
    _ensure_aws_sso || return 1

    AWS_PROFILE="$_CLAUDE_BEDROCK_PROFILE" \
    AWS_REGION="$_CLAUDE_BEDROCK_REGION" \
    CLAUDE_CODE_USE_BEDROCK=1 \
    ANTHROPIC_MODEL="$_CLAUDE_BEDROCK_MODEL" \
    ANTHROPIC_SMALL_FAST_MODEL="$_CLAUDE_BEDROCK_FAST_MODEL" \
    claude "$@"
}

# --- claude-max ---
claude-max() {
    # kill Bedrock routing vars
    unset CLAUDE_CODE_USE_BEDROCK
    unset AWS_PROFILE
    unset AWS_REGION
    unset AWS_ACCESS_KEY_ID
    unset AWS_SECRET_ACCESS_KEY
    unset AWS_SESSION_TOKEN

    # kill direct API overrides so it uses your logged-in Max session
    unset ANTHROPIC_API_KEY
    unset ANTHROPIC_BASE_URL
    unset ANTHROPIC_AUTH_TOKEN

    # don't leak Bedrock model IDs into Max mode
    unset ANTHROPIC_MODEL
    unset ANTHROPIC_SMALL_FAST_MODEL

    claude "$@"
}

# --- claude-run ---
claude-run() {
    local MODE="$1"
    shift

    if [ "$MODE" = "bedrock" ]; then
        _ensure_aws_sso || return 1

        AWS_PROFILE="$_CLAUDE_BEDROCK_PROFILE" \
        AWS_REGION="$_CLAUDE_BEDROCK_REGION" \
        CLAUDE_CODE_USE_BEDROCK=1 \
        ANTHROPIC_MODEL="$_CLAUDE_BEDROCK_MODEL" \
        ANTHROPIC_SMALL_FAST_MODEL="$_CLAUDE_BEDROCK_FAST_MODEL" \
        claude "$@"
    elif [ "$MODE" = "max" ]; then
        unset CLAUDE_CODE_USE_BEDROCK
        unset AWS_PROFILE
        unset AWS_REGION
        unset AWS_ACCESS_KEY_ID
        unset AWS_SECRET_ACCESS_KEY
        unset AWS_SESSION_TOKEN

        unset ANTHROPIC_API_KEY
        unset ANTHROPIC_BASE_URL
        unset ANTHROPIC_AUTH_TOKEN

        unset ANTHROPIC_MODEL
        unset ANTHROPIC_SMALL_FAST_MODEL

        claude "$@"
    else
        echo "usage: claude-run {bedrock|max} [args...]"
        return 1
    fi
}

# Convenience aliases
alias icode-bedrock='claude-bedrock'
alias icode-max='claude-max'

# =========================
# Git shortcuts (cross-platform)
# =========================
alias gst='git status'
alias gss='git status -sb'

alias ga='git add'
alias gaa='git add --all'

alias gb='git branch'
alias gba='git branch -a'

alias gco='git checkout'
alias gcb='git checkout -b'

alias gd='git diff'
alias gds='git diff --staged'

alias gpl='git pull'
alias gp='git push'
alias gpf='git push --force-with-lease'

alias gcm='git commit -m'
alias gca='git commit --amend'
alias gcl='git clone'

# Quick log views
alias gl1='git log --oneline --decorate --graph -n 15'
alias glg='git log --oneline --decorate --graph --all'

# =========================
# Cross-platform clipboard (copy/paste)
# =========================
# Works on: macOS, Linux (X11/Wayland), WSL

copy() {
  if command -v pbcopy >/dev/null 2>&1; then
    pbcopy
  elif command -v wl-copy >/dev/null 2>&1; then
    wl-copy
  elif command -v xclip >/dev/null 2>&1; then
    xclip -selection clipboard
  elif command -v xsel >/dev/null 2>&1; then
    xsel --clipboard --input
  elif command -v clip.exe >/dev/null 2>&1; then
    clip.exe
  else
    echo "No clipboard utility found (pbcopy/wl-copy/xclip/xsel/clip.exe)" >&2
    return 1
  fi
}

paste() {
  if command -v pbpaste >/dev/null 2>&1; then
    pbpaste
  elif command -v wl-paste >/dev/null 2>&1; then
    wl-paste
  elif command -v xclip >/dev/null 2>&1; then
    xclip -selection clipboard -o
  elif command -v xsel >/dev/null 2>&1; then
    xsel --clipboard --output
  elif command -v powershell.exe >/dev/null 2>&1; then
    powershell.exe -command "Get-Clipboard" | tr -d '\r'
  else
    echo "No clipboard utility found (pbpaste/wl-paste/xclip/xsel/powershell.exe)" >&2
    return 1
  fi
}

# Aliases for muscle memory
alias cb='copy'
alias cbp='paste'

# =========================
# Zoxide (smarter cd)
# =========================
# Initialize zoxide if installed - use 'z' to jump to directories
# It learns your habits: z dot → ~/workspace/dotfiles
if command -v zoxide >/dev/null 2>&1; then
  eval "$(zoxide init zsh)"
fi

# Glow alias for reading markdown
if command -v glow >/dev/null 2>&1; then
  alias readme='glow README.md'
  alias md='glow'
fi

# =========================
# zsh-syntax-highlighting (must be at the end)
# =========================
if command -v brew >/dev/null 2>&1; then
  BREW_PREFIX="${BREW_PREFIX:-$(brew --prefix 2>/dev/null)}"
  if [ -n "$BREW_PREFIX" ] && [ -f "$BREW_PREFIX/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" ]; then
    source "$BREW_PREFIX/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
  fi
fi
