package cli

import (
	"fmt"
	"os"
	"runtime"

	"github.com/spf13/cobra"
)

func newShellInitCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "shell-init [shell]",
		Short: "Output shell initialization code",
		Long: `Output shell functions for feature checking and other utilities.

This command outputs shell code that should be eval'd in your shell config.
It provides feature_enabled, require_feature, and other helper functions
that call the Go binary for actual feature state.

Supported shells: zsh, bash, fish, powershell

Usage:
  # In .zshrc or 00-init.zsh
  eval "$(blackdot shell-init zsh)"

  # In .bashrc
  eval "$(blackdot shell-init bash)"

  # In config.fish
  blackdot shell-init fish | source

  # In PowerShell $PROFILE
  Invoke-Expression (blackdot shell-init powershell)`,
		Args: cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			shell := "zsh" // default
			if len(args) > 0 {
				shell = args[0]
			}

			switch shell {
			case "zsh", "bash":
				return outputPosixInit()
			case "fish":
				return outputFishInit()
			case "powershell", "pwsh":
				return outputPowerShellInit()
			default:
				return fmt.Errorf("unsupported shell: %s (supported: zsh, bash, fish, powershell)", shell)
			}
		},
	}

	return cmd
}

func outputPosixInit() error {
	// Get the dotfiles binary path
	dotfilesDir := DotfilesDir()
	binaryPath := fmt.Sprintf("%s/bin/blackdot", dotfilesDir)

	// Check if running on Windows (Git Bash/MSYS)
	if runtime.GOOS == "windows" {
		binaryPath = fmt.Sprintf("%s/bin/blackdot.exe", dotfilesDir)
	}

	script := fmt.Sprintf(`# blackdot shell initialization
# Generated by: blackdot shell-init
# Source this in your shell config: eval "$(blackdot shell-init zsh)"

# Blackdot binary path
_BLACKDOT_BIN="%s"

# Check if a feature is enabled
# Usage: feature_enabled <feature_name>
# Returns: 0 if enabled, 1 if disabled
feature_enabled() {
    local feature="$1"

    # Use Go binary for feature check (suppress all output, just use exit code)
    if [[ -x "$_BLACKDOT_BIN" ]]; then
        "$_BLACKDOT_BIN" features check "$feature" >/dev/null 2>&1
        return $?
    fi

    # Binary not found - features are disabled (safe default)
    # Use BLACKDOT_FEATURE_MODE env var to check system state
    return 1
}

# Require a feature to be enabled before running a command
# Usage: require_feature <feature_name> || return 1
# Prints error message if feature is disabled
require_feature() {
    local feature="$1"
    local silent="${2:-false}"

    if feature_enabled "$feature"; then
        return 0
    fi

    if [[ "$silent" != "true" ]]; then
        echo "Feature '$feature' is disabled." >&2
        echo "Enable with: blackdot features enable $feature" >&2
    fi
    return 1
}

# Check if a feature exists in the registry
# Usage: feature_exists <feature_name>
feature_exists() {
    local feature="$1"

    if [[ -x "$_BLACKDOT_BIN" ]]; then
        "$_BLACKDOT_BIN" features list 2>/dev/null | grep -q "^$feature:"
        return $?
    fi

    return 1
}

# Get feature status (enabled/disabled/unknown)
# Usage: feature_status <feature_name>
feature_status() {
    local feature="$1"

    if [[ -x "$_BLACKDOT_BIN" ]]; then
        if "$_BLACKDOT_BIN" features check "$feature" 2>/dev/null; then
            echo "enabled"
        else
            echo "disabled"
        fi
    else
        echo "unknown"
    fi
}
`, binaryPath)

	fmt.Print(script)
	return nil
}

func outputFishInit() error {
	dotfilesDir := DotfilesDir()
	binaryPath := fmt.Sprintf("%s/bin/blackdot", dotfilesDir)

	if runtime.GOOS == "windows" {
		binaryPath = fmt.Sprintf("%s/bin/blackdot.exe", dotfilesDir)
	}

	script := fmt.Sprintf(`# blackdot shell initialization for fish
# Generated by: blackdot shell-init fish
# Source this in config.fish: blackdot shell-init fish | source

set -g _BLACKDOT_BIN "%s"

function feature_enabled --description "Check if a feature is enabled"
    set -l feature $argv[1]

    if test -x "$_BLACKDOT_BIN"
        $_BLACKDOT_BIN features check "$feature" >/dev/null 2>&1
        return $status
    end

    # Binary not found - features are disabled (safe default)
    return 1
end

function require_feature --description "Require a feature to be enabled"
    set -l feature $argv[1]
    set -l silent $argv[2]

    if feature_enabled "$feature"
        return 0
    end

    if test "$silent" != "true"
        echo "Feature '$feature' is disabled." >&2
        echo "Enable with: blackdot features enable $feature" >&2
    end
    return 1
end

function feature_exists --description "Check if a feature exists"
    set -l feature $argv[1]

    if test -x "$_BLACKDOT_BIN"
        $_BLACKDOT_BIN features list 2>/dev/null | grep -q "^$feature:"
        return $status
    end

    return 1
end
`, binaryPath)

	fmt.Print(script)
	return nil
}

func outputPowerShellInit() error {
	dotfilesDir := DotfilesDir()
	binaryPath := fmt.Sprintf("%s\\bin\\dotfiles.exe", dotfilesDir)

	// Use forward slashes for cross-platform compatibility
	if runtime.GOOS != "windows" {
		binaryPath = fmt.Sprintf("%s/bin/blackdot", dotfilesDir)
	}

	// Build script with string concatenation to handle backtick in PowerShell regex
	script := "# blackdot shell initialization for PowerShell\n" +
		"# Generated by: blackdot shell-init powershell\n" +
		"# Source this in $PROFILE: Invoke-Expression (blackdot shell-init powershell)\n\n" +
		"$script:_BLACKDOT_BIN = \"" + binaryPath + "\"\n\n" +
		`function Test-FeatureEnabled {
    param([string]$Feature)

    if (Test-Path $_BLACKDOT_BIN) {
        $result = & $_BLACKDOT_BIN features check $Feature 2>$null
        return $LASTEXITCODE -eq 0
    }

    # Binary not found - features are disabled (safe default)
    return $false
}

function Assert-FeatureEnabled {
    param(
        [string]$Feature,
        [switch]$Silent
    )

    if (Test-FeatureEnabled -Feature $Feature) {
        return $true
    }

    if (-not $Silent) {
        Write-Error "Feature '$Feature' is disabled."
        Write-Host "Enable with: blackdot features enable $Feature" -ForegroundColor Yellow
    }
    return $false
}

function Test-FeatureExists {
    param([string]$Feature)

    if (Test-Path $_BLACKDOT_BIN) {
        $features = & $_BLACKDOT_BIN features list 2>$null
        # Match feature name at start of line followed by colon
        return ($features | Select-String -Pattern ("^" + $Feature + ":")) -ne $null
    }

    return $false
}

# Aliases for compatibility
Set-Alias -Name feature_enabled -Value Test-FeatureEnabled
Set-Alias -Name require_feature -Value Assert-FeatureEnabled
Set-Alias -Name feature_exists -Value Test-FeatureExists
`

	fmt.Print(script)
	return nil
}

// init registers shell-init command
func init() {
	// Command is added in root.go
	_ = os.Getenv("SHELL") // Just to use os package
}
